Spring takes components from Jakartaka if concept is helpful to developers. / Spring borrows the annotations from Java EE.

How to create a project in IntelliJ:
            Open new Project -> Name project -> Select Location to be stored -> Build system: Maven -> Java JDK 17 -> Create it.

            To use Spring Framework in our project, we need to include it "pom.xml" file. Copy "GAV" from mvnRepository website.
            
            Note:
                To identify a project uniquely "GAV" is used. 
                {"GroupID", "ArtifactID" and "Version" are combined to create a key.}
                    GroupID     -   It represents that which organization's project is this. 
                                    If it is Google.com then Group ID will be com.Google
                    ArtifactID  -   It's project name which you decide while creating a project.
                    Version     -   Release version of Project. ex., V3.0.1 

Loosely Coupling V/S Tightly Coupling:
            When A classes are highly depedent on each other, making changes to them is difficult and requires more testing and less resuable.
            ex.,
                main class directly initiats JSON class and uses CreateDoc method.

            When Classes are independent of each other, making changes are more flexible and require less testing and more resuable.
            ex.,
                main class uses interface which allow dev to use any class.

            NOTE:
                    To create Loosely coupling:
                        - implment Interface/ Abstract classes
                        - Dependency Injection { In constructor, Setter or Interface }
                        - Factory pattern (implement Interface so subClasses can be changed.)
                        (many more)

            -> If dev team are using AWS as cloud service and later they found AWS is charging much higher than it used to and client can not afford it. So dev team have to use another cloud service like GCS. 
                So, if devs initiate classes directly and want to change make change then it will be so difficult as it is tightly coupling case.
                But if dev used interfaces and passing classes as parameters. it will be easy to make changes as we need to create new method in interface. It is loosely coupling example.

            EXAMPLE:
                    Tightly Coupling:
                            Class PDF{
                                String print(){
                                    return "PDF has been created";
                                }
                            }

                            main{
                                PDF pdf= new PDF();
                                System.out.println(pdf.print());
                            }

                    Loosely Coupling:
                            interface generator(){
                                public void output();
                            }

                            class PDF implements generator{
                                String print(){
                                    return "PDF has been created";
                                }
                            }

                            class WORD implements generator{
                                Stirng print(){
                                    return "WORD has been created";
                                }
                            }

                            Class docs{
                                private generator();

                                public docGenerate(generator Gen){
                                    this.generator= Gen;
                                }

                                void print(){
                                    System.out.println(Gen.print());
                                }
                            } 

                            main{
                                generator pdf= new generator();
                                docs D1= new docs(pdf);
                                // return PDF
                                D1.print();

                                generator word= new generator();
                                docs D2= new docs(word);
                                // return WORD
                                D2.print();
                            }

           
            Loosely Coupling V/S Tightly Coupling:
                Definition :
                            ->  Classes or modules are highly dependent on each other.
                            ->  Classes or modules are independent and rely on abstractions. 
                | Flexibility         | 
                Low. Changes in one class require changes in others. 
                High. Components can be easily swapped or modified. |
                | Maintainability     | 
                Difficult. Harder to update, fix bugs, or add features. 
                Easier. Changes are isolated, reducing the impact on the system. |
                | Testing             | 
                Challenging. Difficult to isolate and mock components.
                Easier. Components can be easily tested in isolation. |
                | Reusability         | 
                Low. Reusing a class in a different context is difficult.
                High. Components are more modular and can be reused easily. |
                | Performance         | 
                Often better, as there's no overhead from abstraction. 
                Potential overhead due to abstraction layers or DI frameworks. |
                | Simplicity          | 
                Simpler to implement for small-scale projects.
                More complex, requires careful design and use of patterns. |
                | Dependency Management | 
                Direct. Classes explicitly instantiate and manage dependencies. | 
                Indirect. Dependencies are managed through interfaces or DI. |
                | Design Effort       | 
                Requires less upfront design. | 
                Requires more upfront design and architectural planning. As we need to create interfaces and classes as well.
                | Code Change Impact  | 
                High. A change in one module can affect many others. | 
                Low. Changes in one module have minimal impact on others. Just need to change parameter in main method.
                | Examples            | 
                Direct instantiation of objects within a class. | 
                Use of interfaces, abstract classes, or dependency injection. |
                | Risk of Over-Engineering | 
                Low. Fewer abstractions lead to simpler code. | 
                Higher. Abstractions can sometimes lead to unnecessary complexity. Unneccessary implementation of interface when it can be done easily by classes only.

How execution is performed: 
        Your main logic is separated from the object creation/configuration logic. 
        Spring handles the instantiation of beans, making your code more modular and maintainable.

        Conversion in main.java file:
            IoC container (context) --> Extract Bean component --> perform action
            ex.,
                var context = new AnnotationConfigApplicationContext(projectConfig.java);
                var beanComponent = context.getBean("classname", String);
                System.out.println("Access_Spring" + beanComponent.getName());

        NOTE:
            All bean components (singleton beans) are created from top to down when ApplicationContext is initialized.

Concept that I understand:
            -> 
                If you want to create Beans manually, we need to configure configuration file.
                This will give more freedom to choose which bean compoent we want to use.
                Where @Autowire is allowed to use inside Bean component.

Annotations  :
            Custom Bean name:
                        // Bean naming using "name" keyword:
                            @Bean(name = "Vehicle1")
                            Vehicle v1(){
                                return new createVehicle("BMW");
                            }

                        // Bean naming using "value" keyword:
                            @Bean(value = "Vehicle2")
                            Vehicle v2(){
                                return new createVehicle("Audi");
                            }

                        // Bean naming using Shortcut method:
                            @Bean("Vehicle3")
                            Vehicle v3(){
                                return new createVehicle("GWagon");
                            }

                Note: 
                        If bean components have same name, it will overwrite names and you will be able to access only one. 
                        The one which you can access is soly based on how spring processes.
                        ex.,
                            // projectConfig.java
                                @Bean(name = "v24")
                                Vehicle vehicle(){
                                    return new Vehicle("krunal", "BMW");
                                }

                                @Bean(name = "v24")
                                Vehicle vehicle2024(){
                                    return new Vehicle("2nd Class", "panda");
                                }

                            // main.java
                                System.out.println(context.getBean("v24", Vehicle.class));
                                --> It could be first or last bean compoent of same custom bean name.

            @Primary:
                        It decides default bean when user is trying to fetch Vehicle type bean.
                        ex., context.getBean(Vehicle.class);

                        @Primary annotation will make that Bean default bean.
                        ex.,
                            // projectConfig.java
                                @Bean
                                Vehicle vehicle(){
                                    return new Vehicle("krunal", "BMW");
                                }

                                @Primary
                                @Bean
                                Vehicle vehicle2024(){
                                    return new Vehicle("2nd Class", "audi");
                                }

                            // main.java
                                System.out.println(context.getBean(Vehicle.class));
                                --> Primary bean will be returned here.

                        Note: 
                            We can assign @Primary annotation to multiple Beans which result in NoUniqueBeanDefinitionException.

                            ex.,
                                // projectConfig.java
                                    @Primary
                                    @Bean
                                    Vehicle vehicle() {
                                        var veh = new Vehicle();
                                        veh.setName("Audi 8");
                                        return veh;
                                    }

                                    @Primary
                                    @Bean
                                    Vehicle vehicle2() {
                                        var veh = new Vehicle();
                                        veh.setName("bmw");
                                        return veh;
                                    }

                                // main.java
                                Vehicle v = context.getBean("audi", "Vehicle.class");

                                --> result in exception

                        NOTE:

                            ex.,
                                // projectConfig.java
                                    @Primary
                                    @Bean("audi")
                                    Vehicle vehicle() {
                                        var veh = new Vehicle();
                                        veh.setName("Audi 8");
                                        return veh;
                                    }

                                    @Primary
                                    @Bean("bmw")
                                    Vehicle vehicle2() {
                                        var veh = new Vehicle();
                                        veh.setName("bmw");
                                        return veh;
                                    }

                                // main.java
                                Vehicle v = context.getBean("audi", "Vehicle.class");

                                --> getContext() will look for only Vehicle bean whose name is "audi". As a result, it won't thorw exception because only one bean found with "audi" name.

                                if we found multiple bean with "audi" name, it will resturn @primary annoted Vehicle bean.

                                NOTE:
                                    if you have beans with "audi" names and mistakenly assign @Primary to multiple beans. it will throw NoUniqueBeanDefinitionException.

            @Component:
                        in real world to avoid writing @bean for all class; we write @component Annotation on class definition.

                        NOTE:
                            Spring will automatically create a single bean. (as part of Singleton bean scope)
                            To create more beans of same class, we need to use @CompoentScan in config file.

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:
                                }

                            // productConfig file
                                @ComponentScan(com.kpriyadarshi.beans);  --> this will scan all files from "Beans" folders.
                                public class ProjectConfig {
                                    ... empty file - as bean will be created with @CompoentScan ...
                                }

                            result -> when we run method. it will print Null for vehicle name. As we haven't assign value.

            @ComponentScan:
                        Spring has default feature to scan components where @Configuration or @SpringBootApplication is mentioned.
                        But when @Component is used we need to use @ComponentScan so that we know which beans to create.
                        
                        We need to include in a file where beans are created. Generally we mention this inside Config files.

                        ex.,
                            //productConfig.java
                                @ComponentScan(basePackage= "com.example.beans")
                                class productConfig(){
                                    ... methods to create beans ...
                                }

                        ComponentScan has more parameters...
                            @ComponentScan(
                                basePackage = "com.example.beans",
                                includeFilters = ...,
                                excludeFilters = ...
                            )

            @PostConstruct:
                        Executes when bean is created but constructor execute first.
                        NOTE:
                            First class's constructor is initialized. and after that @PostConstruct is executed.
                            -> If B is child class of A then first A's constructor will execute then B's constructor will execute after that A's @PostConstruct and B's @PostConstruct execute.

                        It is used to ensure custom configuration and logic has been implemented before the execution it is used.                       

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:

                                    @PostConstruct
                                    public void init(){
                                        this.name = "Honda";
                                    }
                                }

                            Result -> It will assign "honda" name to Vehicle class. else it will show null value when we try to print name of it.

            @PreDestroy:
                        Executes automatically when bean is being destroyed by spring framework.
                        Used to disconnect database, close file, Release a source etc.

                        NOTE: To use @PreDestroy annotation, we need to close ApplicationContext.

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:

                                    @PreDestroy
                                    public void destroy(){
                                        System.out.println("Closing Vehicle bean: " + this.name + "!");
                                    }
                                }

                            // Main.java
                                public static void main(String[] args) {
                                    var context = new AnnotationConfigApplicationContext(ProductConfig.class);
                                    -- use below line to execute @PreDestroy annotation:
                                    context.close();
                                }
                            
                            Result: It will execute @PreDestroy methods.

Hardcorded dependency/ Thight Coupling :: 
                        Vehicle class manually assigned to Person class in the configuration file. 
                        Doing so create Manual and TIGHTLY COUPLING.
                            ex.,
                                // productConfig.java
                                    @Configuration
                                    public class ProjectConfig {

                                        @Bean
                                        public Vehicle vehicle() {
                                            Vehicle veh = new Vehicle();
                                            veh.setName("Audi 8");
                                            return veh;
                                        }

                                        @Bean
                                        public Person person() {
                                            Person person = new Person();
                                            person.setName("John");
                                            person.setVehicle(vehicle()); // Manually setting dependency
                                            return person;
                                        }
                                    }

                        Now We want to add Model field (from CAR class which is subclass of Vehicle) to above code:
                            ex.,
                                // Create Car.java file with one field "modelName". 

                                // ProductConfig.java   
                                    @Primary
                                    @Bean
                                    public Vehicle createVehicle1(){
                                        var car = new Car();
                                        car.setModelName("i3");
                                        car.setName("BMW");
                                        return car;
                                    } 

                        Here, we need to change whole createVehicle1() method. 
                        Just imagine if we have x5 methods then we need to change entire ProductConfig.java file.

Wiring beans/ Loose Coupling   ::
                Remember, with one constructor we do not need to use @Autowired. It is optional and it will consider a dependency between both beans.

                Wiring beans using Method parameters: 
                        { Not a Good way to wire components as when change occures, We have to make changes everywhere. }
                            
                            In productConfig file, we will have person() method. 
                            Where we will use setVehicle() method from Person class and pass existing vehicle method from "productConfig" file.
                            ex., 
                                public Vehicle veh_Method(){
                                    Vehicle v = new Vehicle();
                                    v.setName("1k");
                                    return v;   
                                }

                                public Person person_Method(){
                                    Person p = new Person();
                                    p.setVehicle(veh_Method());  // method name is passed as parameter.
                                    return p;
                                }

                            NOTE:
                                ->  Instead of creating Vehicle bean for veh_method and person_method, Spring as default behaviour creates one Vehicle bean and give them. 
                                    You can use print statement in both constructors to validate above statement.
                                ->  We won't face any ambiguity as we are passing method name inside person method.

                Wiring beans using method calls:
                            Here, we will pass parameter "Vehicle veh_Temp". and everything is wired by spring. 
                            ex.,
                                public Person person_Method(Vehicle veh_Temp){
                                    Person p = new Person();
                                    p.setVehicle(Vehicle veh_Temp);  // instead of passing method name, we are passing object.
                                    return p;
                                } 

                            NOTE: As auto wiring is done by spring, we might face ambiguity if we have 2 beans with same data type.
                                    To avoid, we can use @Primary annotation.
                                    or @Qualifier("name_of_bean") annotation.                                    
                                    or It will match with the name given on parameter inside class and name given on configProduct file.

                                    ex.,
                                        class person{
                                            
                                        }

                Wiring beans using @Wiring annotation   : 
                                @Wiring annotation can be placed on bean class OR Setter method.

                                NOTE: There is a limitation that a bean variable can't be final. Because value is yet to assign.

                                ex.,
                                    @Component
                                    class Person{
                                        priavte final String name = "Krunal";

                                        @Autowired
                                        priavte Vehicle veh;

                                        @Autowired
                                        public void setVehicle(Vehicle vehicle) {
                                            this.vehicle = vehicle;
                                        }
                                    }

                                @Wiring annotation goes well with @Component because it will automatically wire vehicle to person object.
                                since @component does allow to create multiple instance we will not face ambiguity.

                                Exception is thrown if bean does not exist.

                                ex.,
                                    // only add @autowire to variable in Person() class. if we do not do that vehicle will be NULL for person object.

                                NOTE:
                                    We can trun off "@autowire(required = false)" to avoid exception if bean not found and assign NULL value to it.
                                    Also, we can not use final keyword with @autowired variable.
                 
                Wiring beans using @Wiring on constructor   :
                                To use final keyword for bean variable, we have to implement this method and it's accepted for production.

                                Use it with constructor:
                                ex.,    
                                    public class Person{
                                        priavte final Vehicle veh;

                                        @Autowired
                                        public Person(Vehicle veh){
                                            this.veh = veh;
                                        }
                                    }

                                NOTE:
                                    ->  you can't use default/ zero parametered constructor. as vehicle variable expect value.
                                    ->  @Qualifier can't be used with @Autowire but can be used inside parameter:
                                        ex.,
                                            // Runtime error:
                                                @Autowire
                                                @Qualifier ---> can not be used here wit constructor.
                                                public Person(Vehicle veh){
                                                    ... code ...
                                                }

                                        ex., 
                                            // Works:
                                                @Autowire
                                                public Person( (@Qualifier "Vehicle1") Vehicle veh){
                                                    ... code ....
                                                }

                                    ->  if class has only one constructor, we don't need to write @autowired as it will applied default. but make sure it is not default constructor with 0 parameter.

                                    ex.,
                                        public class Person{
                                            private final Vehicle veh;

                                            ---- writing @autowire is optional ----
                                            public Person(Vehicle veh){
                                                this.veh = veh;
                                            }
                                        }

                Autowiring with multiple Beans of same type :
                                        Spring will try to match Beans with same type. If type is Vehicle then it will try to find same type Bean. 

                                        If multiple is found, it will try to match parameter name but this way has less readibility as anything can be used as parameter so it is not adviced to use.

                                            ex.,                                                
                                                // ProductConfig file
                                                    @Configuration
                                                    class productConfig{
                                                        public Vehicle v1(){
                                                            ...
                                                        }

                                                        public vehicle v2(){
                                                            ...
                                                        }

                                                        @Primary
                                                        public vehicle v3(){
                                                            ...
                                                        }
                                                    }

                                                
                                                // Person.java
                                                    Class Person{
                                                        private final Vehicle veh;

                                                        @Autowire
                                                        public Person(Vehicle v1){
                                                            ... ...
                                                        }
                                                    }

                                                    RESULT: 
                                                        Spring will try to find same type bean but here 3 beans are found. {v1, v2, v3}. so spring will try to match with parameter name in constructor with name of vehicle method from config file.

                                                        As V1 method from config file matches it will show value as per v1.

                                                        If variable name did not match with any method from config file, it will choose @Primary bean.

                                                        OR you can use @Qualifier in constructor.
                                                        ex.,
                                                            // Person.javaClass 
                                                                Person{
                                                                    private final Vehicle veh;

                                                                    @Autowire
                                                                    public Person(@Qualifier("v1") Vehicle veh){
                                                                        ... ...
                                                                    }
                                                                }

Bean Scope:
        - Singleton Bean (Default)
        - Prototype Bean
        - Request
        - Session
        - Application

        Syntex -->   " @Scope(BeanDefinition.SCOPE_PROTOTYPE) "

            Singleton (Default) ::
                            Singleton instantiation is default way Where same object is returned for Bean reference. 
                            Singleton Bean have Eager and Lazy concept for Bean creation.

                            Flaw/ Disadvantage -> 
                                When two users tries to access same data, it will create "RACE CONDITION". Where final value depends on last applied changes. It occurs for tread process.
                                ex.,
                                    We have one hashtable. here user1 and user2 tried to change value of key "animal". User1 changed value to "lion" but other changed to "cat". But value of "animal" depends on which thread arrived at last.

                            ex.,
                                HERE single bean "Vehicle" is accessed by V1 and V2 objects. If you print address of object it will same.

                                // Config file:
                                    class productConfig{
                                        @Bean
                                        public Vehicle vehicle(){
                                            return new Vehicle();
                                        }
                                    }

                                // main file:
                                    Vehicle v1 = context.getBean(Vehicle.class);
                                    System.out.println(v1.toString() + " --------------");

                                    Vehicle v2 = context.getBean(Vehicle.class);
                                    System.out.println(v2.toString() + " --------------");
                                    
                                    if(v2 == v1)
                                        System.out.println("same address");
                                    System.out.println(v2.hashCode());
                                    System.out.println(v1.hashCode());

                                    // Changing value on one object reflact on other object as same bean is used for both.
                                    v1.setName("no way");
                                    System.out.println(v2.toString());

            Prototype   ::
                            Prototype used to avoid RACE CONDITION occured by Singleton approach.
                            Here, New object is returned for each Bean reference.
                            Prototype bean does not have Eager instantiation concept because beans are created when needed. 

                            | Scenario                         | Person Scope | Vehicle Scope | Behavior                                                                 |
                            |----------------------------------|--------------|---------------|--------------------------------------------------------------------------|
                            | Both are prototype               | Prototype    | Prototype     | New Person and Vehicle instances are created for each getBean() call.    |
                            | Person: singleton, Vehicle: prototype | Singleton    | Prototype     | Person is shared, but each call to createVehicle() returns a new Vehicle.|
                            | Both are singleton               | Singleton    | Singleton     | Both Person and Vehicle instances are shared. Modifying one affects all references. |

                            ex.,
                                // Person is Singleton while Vehicle is Prototype:
                                    // Config file:
                                        @Configuration
                                        public class AppConfig {

                                            @Bean
                                            @Scope(BeanDefinition.SCOPE_PROTOTYPE)
                                            public Vehicle vehicle() {
                                                return new Vehicle();
                                            }

                                            @Bean
                                            public Person person() { // Singleton by default
                                                return new Person();
                                            }
                                        }

Singleton V/S Prototype ::
        > Singleton is default scope While Prototype is defined scope.
        > Singleton same objects for each bean reference while Prototype scope will return different object for each bean reference.
        > Singleton is used for immutable objects while Prototype used for Mutable object. 
        > singleton is commonly used scope while prototype is rarely used scope.

Singleton Eager & Lazy instantiation ::
                Eager instntiation is deafult behaviour of Spring. Where all beans are created at first by Spring. 
                This approach has one flaw that as all beans are created at first it might take time. Even those bean which we are going to use rarely. For example, Bean creation for "Deactivate my account". Which is rarely used in general.
                
                Hence Lazy instantiation was introduced to avoid bean creation at start. And create bean on demand.

                Eager V/S Lazy:
                    >   Spring's default behavior is Eager while Lazy is defined behaviour.
                    >   Eager will create all Beans at start. While Lazy will create bean on demand.
                    >   Eager will throw exceptions/errors before server start while we might face exceptions/errors using Lazy. ex., Lazy tries to create Bean during execution and it might not be found in IOC container and throws Exception.
                    >   Eager takes lots of space as all Beans are created and reduce Performance. Use of Lazy, maintains performance.
                    >   Eager is used in mostly cases but Lazy is used for rare cases.

                ex.,  
                    If we use @Lazy annotation, bean will created when are using getBean() method. we will see "Bean Creation" printed and after that "Vehicle is created".
                    Without @Lazy, spring will use default @Eagar annotation, where all beans are created. so we will see "Vehicle is created" before "Bean Creation".
                    
                    // Vehicle class:
                        class Vehicle{
                            public Vehicle(){
                                System.out.println("Vehicle is created.");
                            }
                        }
                    // config file:
                        class productConfig{
                            @Bean
                            @Lazy
                            public Vehicle veh(){
                                ...
                            }
                        }
                    // Main file:
                        var context = new ApplicationConfigApplicationContext(productConfig.java);
                        sout("-------- Bean Creation ------------")
                        Var vehicle = context.getBean(Vehicle.class);

AOP (Aspect Oriented Programming):
            Aspect is a logic/programming-code which contains cross-cutting concerns. Where Cross-cutting concerns includes performance monitoring logs, security, transcation management, logging etc,.

            AOP centralized this concerns in separated file. 
            ex.,
                To understand better, let's say we want to check execution start time, end time and total time taken of given Java file inside project.
                To do that, We can write single code. But what if we want to do this for java files inside Beans folder. Then we need to write this non-business code for all java files.  
                To reduce this, we use @Aspect file where we will create a method and write all non-business code. And access whenever we want ny simple adding "Advices" of AOP.

            Advantages of AOP:
                Modularization: Separates cross-cutting concerns from the main logic.
                Reusability: Allows you to reuse aspects across multiple modules.
                Clean Code: Reduces boilerplate code by moving repeated logic to a centralized aspect.
                Improved Maintenance: Easier to update or enhance cross-cutting concerns without modifying business logic.

            Function V/S AOP Aspect:
                AOP Aspect is some what same as Function. Where we define logic somewhere and later we call it where we need to use it. But Both are different.,
                >
                    Fuction follows Scatter Apporach. Function needs to be explicitly called where logic is required.
                    Aspect follows centralized Approach. Where logic, rules and everything is written on same file. We do not need to call them from Main method.
                >
                    Duplication for Function call. If we want to use logic in 10 places, we need to call function from each point.
                    Single Aspect call. Defined Point-cut Expression will make all call.
                >
                    Function creates Thighly Coupling.
                    Aspect creates Loosely Coupling.
                > 
                    Functions clutters the business logic. As we are writing non-business logic inside main method.
                    With AOP Aspect, all concerns are handled without touching Business logic.
                >
                    As business grow, developers might create new methods. And they might forget to add logging Functions to logic.
                    Because of Point-cut Expression, Aspect is applied to automatically and leave no room for human error. 

            NOTE: How to use Aspect inside Project:
                To use AspectJ in project.,
                >   We need to include Dependency inside POM.xml file.  
                >   In config file, enable AOP flag by @EnableAspectJAutoProxy. Which lets Spring know about AOP being used in project.
                >   In Aspect file, use @Component and @Aspect. 
                        @Aspect used to define class as an Aspect. Without it, Spring won't use advices (@Before, @After etc.,) or other Aspect logic.
                        @Component used to ensure class is a bean and it is eligible for Spring lifecycle.
                    
            AOP Jargons:
                Target Object   -   A class on which Aspect code will be intercept.
                Aspect          -   A class in which Aspect code is written.

                Advices         -   Advices are defined action on aspect methods. ex., @Before, @After, @Around
                Point Cut       -   AKA Point Cut Expression. Which specify where the advice should be applied. 
                Join Point      -   From Target Object, methods on which Advice will be applied to.

                ex.,
                    // Vehicle class:   "Vehicle.java" file
                        Class Vehicle{
                            private String name;

                            public void process(){
                                this.name += " @CanadianVersion";
                            }
                        }

                    // Aspect Class:    "LogginAspect.java" file
                        @Component
                        @Aspect
                        public class LogginAspect{
                            @Before("execution(* com.example.service.Vehicle.process(..)))
                            public void logging(){
                                System.out.println("---- Log: Accesing Vehicle ----");
                            }

                            @After("execution(* com.example.service.Vehicle.process(..)))
                            public void exitLogging(){
                                System.out.println("---- Log: Releasing Vehicle ----");
                            }
                        }

            ADVICE types:
                @Before             -   Befre the execution of method, Advice is applied.
                @AfterReturning     -   After the succesful execution of method, Advice is applied.
                @AfterThrowing      -   After Exception is thrown in target method, Advice is applied.
                @After              -   Advice is applied after the execution of method. (no matter exception is thrown or not.)
                @Around             -   Combination of @Before and @After.
                
            Point-cut expression syntex:
                    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
                    
                    NOTE:
                            package com.exmaple;
                            public class Solution{
                                public int checkMaxVal(int[] nums) thorw NullPointerException{
                                    ...     // implementation
                                }
                            }

                            --> modifiers-pattern is "public".
                            --> ret-type-pattern is "int".
                            --> declaring-type-pattern is "com.exmaple.Solution".   { It is combination of PackageName + ClassName.}
                            --> name-pattern is "checkMaxVal".  {It is method name.}
                            --> param-pattern is "int[]".   {It is parameter's data type.}
                            --> throws-pattern is "NullPointerException".

Exceptions  :
                NoSuchBeanDefinitionException       :
                            When you try to get bean using context.getBean("Vehicle.class") and no vehicle bean is found from IOC container. It will return this exception.

                NoUniqueBeanDefinitionException     :
                            When you try to inject a bean by a type but project config file has multiple beans with same type, this Exception is thrown.
                            ex.,
                                // projectConfig.java
                                    @bean
                                    String firstName(){
                                        return "John";
                                    }

                                    @bean 
                                    String lastName(){
                                        return "Doe";
                                    }

                                // main.java
                                    var context = new AnnotationConfigApplicationContext(projectConfig.class);
                                    var name = context.getBean(String.class);  
                                    // Exception will be thrown as there are two beans with same type.   

                                    //use this instead:
                                    var name = context.getBean("firstName", String.class);  // John
                                    var name2 = context.getBean("lastName", String.class);  // Doe

                                    // Or use @Primary Annotation in projectConfig.java class.
                                
                            NOTE:   
                                if we have x2 @Primary annotation for same data types we will get Exception "NoUniqueBeanDefinitionException" with proper message saying "more than 1 @Primary annotation".

                UnsatisfiedDependencyException      :
                            When Circular dependency is created, this exception is thrown.
                            When A bean trying initiate another bean and other bean is try to initiate first bean. This exception is thrown. 
                            There is no solution for this. So we have to avoid this situation.

                            It can be easily discovered as we can not even start out server.

                            ex.,
                            // Circular dependency:
                                class person{
                                    @Autowired
                                    private Vehicle veh; // person class is trying to initiate vehicle class.
                                }

                                class Vehicle{
                                    @Autowired
                                    private Person p;   // vehicle class is trying to initiate person class.
                                }