interface   :
            Interface is used to achieve loosely coupling between components.
            Interface is used to achieve Abstraction and multiple inheritance.

            NOTE:
                Variable inside Interface is by default "public static final".

            ABSTRACT METHOD(NORMAL WAY):
                    We must have to use all interface method inside class.
                        interface A{
                            void call();
                        }
                        class B implements A{
                            // Mandatory implementation
                            void call(){
                                System.out.println("call method");
                            }
                        }
            DEFAULT METHODS:
                    It is optional method. 
                    It can be accessible from class object.
                    It can be overridden.
                        interface A{
                            default void call();
                        }
                        class B implements A{
                            // optinal to use call() method from interface.
                            ..
                        }
            STATIC WAY:
                    Static method can be accessible by interface only. We can't access static method from object of a class.
                        example.
                            interface A{
                                static void call(){
                                    System.out.println("interface instance");
                                }
                            }
                            class B implements A{
                                // Can not override static method of interface.
                                /*
                                /   @Override
                                /   static void call(){...}  // ERROR: Cannot use static method with @Override
                                */
                                ..
                            }
                            class Test {
                                public static void main(String[] args) {
                                    A.info(); // Access via interface
                                    // obj.info(); // ERROR: Cannot access via object
                                }
                            }

            Marker Interface:
                        A interface without fields and methods.
                        These interfaces used as meta data so that we can create logic based on meta data. 
                        Lets say a class has Cloneable marker interface implemented which means that class can be cloned. But it does not implement cloneable interface than it will throw custom exception when tried to access it.
                        
                        There are few Marker interface: 
                            Cloneable       -   A meta data to tell if class is cloneable or not.
                            Remote          -   A meta data to tell if class is remote or not.
                            Serializable    -    
                                Used to mark a class if it is Serializable.
                                We can define logic based on class's meta data.
                                At runtime, we can check instance as meta data and apply behavior. like if is Seriablizable we can stream object but if not, we can throw custom exception.
                                    example.,
                                        interface Serializable{
                                            // Empty interface
                                        }
                                        class Person implements Serializable{
                                            private String name;
                                            public void setName(String name){this.name = name;}
                                            public String getName(return name);
                                        }
                                        class Test{
                                            public static void main(String[] args) {
                                                Person p = new Person();
                                                System.out.println(p instanceof Seriablizable);  // Used to check if it supports Serializable. Which is used as Meta data.
                                            }
                                        }  

            Functional Interface:
                        A functional interface is a interface with only one method. 
                            But to avoid confusion from regular interface (which can have one or more than one method), we are using Annotation "Functional interface" on top of interface. Which forces interface to use only one method else throw error.
                        
                        Main use of Funcitonal Interface is to use lambda function.

                        example.,
                            // Regular way to use Functional interface: 
                                    @FunctionalInterface
                                    interface Calculator{
                                        void compute(int a, int b);
                                    }

                                    class Test{
                                        public static void main(String[] args) {
                                            Calculator add = new Calculator() {
                                                // Creating a object that implement interface.
                                                @Override
                                                public void compute(int a, int b) {
                                                    System.out.println(a+b);
                                                }
                                            };
                                        }
                                    }
                            
                            // Using Functional interface as Lambda function: (only parameters)
                                    @FunctionalInterface
                                    interface Calculator{
                                        void compute(int a, int b);
                                    }

                                    class Test{
                                        public static void main(String[] args) {
                                            Calculator add = (int a, int b) -> System.out.println(a+b);

                                            add.compute(10, 20);
                                        }
                                    }
                            
                            // Using Functional interface as Lambda function: (parameters with return value)
                                    @FunctionalInterface
                                    interface Calculator{
                                        int compute(int a, int b);
                                    }

                                    class Test{
                                        public static void main(String[] args) {
                                            Calculator add = (int a, int b) -> (a+b);

                                            int result = add.compute(10, 20);
                                            System.out.println(result);
                                        }
                                    }

Spring takes components from Jakartaka if concept is helpful to developers. / Spring borrows the annotations from Java EE.

How to create a project in IntelliJ:
            Open new Project -> Name project -> Select Location to be stored -> Build system: Maven -> Java JDK 17 -> Create it.

            To use Spring Framework in our project, we need to include it "pom.xml" file. Copy "GAV" from mvnRepository website.
            
            Note:
                To identify a project uniquely "GAV" is used. 
                {"GroupID", "ArtifactID" and "Version" are combined to create a key.}
                    GroupID     -   It represents that which organization's project is this. 
                                    If it is Google.com then Group ID will be com.Google
                    ArtifactID  -   It's project name which you decide while creating a project.
                    Version     -   Release version of Project. ex., V3.0.1 

Loosely Coupling V/S Tightly Coupling:
            When A classes are highly depedent on each other, making changes to them is difficult and requires more testing and less resuable.
            ex.,
                main class directly initiats JSON class and uses CreateDoc method.

            When Classes are independent of each other, making changes are more flexible and require less testing and more resuable.
            ex.,
                main class uses interface which allow dev to use any class.

            NOTE:
                    To create Loosely coupling:
                        - implment Interface/ Abstract classes
                        - Dependency Injection { In constructor, Setter or Interface }
                        - Factory pattern (implement Interface so subClasses can be changed.)
                        (many more)

            -> If dev team are using AWS as cloud service and later they found AWS is charging much higher than it used to and client can not afford it. So dev team have to use another cloud service like GCS. 
                So, if devs initiate classes directly and want to change make change then it will be so difficult as it is tightly coupling case.
                But if dev used interfaces and passing classes as parameters. it will be easy to make changes as we need to create new method in interface. It is loosely coupling example.

            EXAMPLE:
                    Tightly Coupling:
                            Class PDF{
                                String print(){
                                    return "PDF has been created";
                                }
                            }

                            main{
                                PDF pdf= new PDF();
                                System.out.println(pdf.print());
                            }

                    Loosely Coupling:
                            interface generator(){
                                public void output();
                            }

                            class PDF implements generator{
                                String print(){
                                    return "PDF has been created";
                                }
                            }

                            class WORD implements generator{
                                Stirng print(){
                                    return "WORD has been created";
                                }
                            }

                            Class docs{
                                private generator();

                                public docGenerate(generator Gen){
                                    this.generator= Gen;
                                }

                                void print(){
                                    System.out.println(Gen.print());
                                }
                            } 

                            main{
                                generator pdf= new generator();
                                docs D1= new docs(pdf);
                                // return PDF
                                D1.print();

                                generator word= new generator();
                                docs D2= new docs(word);
                                // return WORD
                                D2.print();
                            }

           
            Loosely Coupling V/S Tightly Coupling:
                Definition :
                            ->  Classes or modules are highly dependent on each other.
                            ->  Classes or modules are independent and rely on abstractions. 
                | Flexibility         | 
                Low. Changes in one class require changes in others. 
                High. Components can be easily swapped or modified. |
                | Maintainability     | 
                Difficult. Harder to update, fix bugs, or add features. 
                Easier. Changes are isolated, reducing the impact on the system. |
                | Testing             | 
                Challenging. Difficult to isolate and mock components.
                Easier. Components can be easily tested in isolation. |
                | Reusability         | 
                Low. Reusing a class in a different context is difficult.
                High. Components are more modular and can be reused easily. |
                | Performance         | 
                Often better, as there's no overhead from abstraction. 
                Potential overhead due to abstraction layers or DI frameworks. |
                | Simplicity          | 
                Simpler to implement for small-scale projects.
                More complex, requires careful design and use of patterns. |
                | Dependency Management | 
                Direct. Classes explicitly instantiate and manage dependencies. | 
                Indirect. Dependencies are managed through interfaces or DI. |
                | Design Effort       | 
                Requires less upfront design. | 
                Requires more upfront design and architectural planning. As we need to create interfaces and classes as well.
                | Code Change Impact  | 
                High. A change in one module can affect many others. | 
                Low. Changes in one module have minimal impact on others. Just need to change parameter in main method.
                | Examples            | 
                Direct instantiation of objects within a class. | 
                Use of interfaces, abstract classes, or dependency injection. |
                | Risk of Over-Engineering | 
                Low. Fewer abstractions lead to simpler code. | 
                Higher. Abstractions can sometimes lead to unnecessary complexity. Unneccessary implementation of interface when it can be done easily by classes only.

How execution is performed: 
        Your main logic is separated from the object creation/configuration logic. 
        Spring handles the instantiation of beans, making your code more modular and maintainable.

        Conversion in main.java file:
            IoC container (context) --> Extract Bean component --> perform action
            ex.,
                var context = new AnnotationConfigApplicationContext(projectConfig.java);
                var beanComponent = context.getBean("classname", String);
                System.out.println("Access_Spring" + beanComponent.getName());

        NOTE:
            All bean components (singleton beans) are created from top to down when ApplicationContext is initialized.

Concept that I understand:
            -> 
                If you want to create Beans manually, we need to configure configuration file.
                This will give more freedom to choose which bean compoent we want to use.
                Where @Autowire is allowed to use inside Bean component.

Annotations  :
            Custom Bean name:
                        // Bean naming using "name" keyword:
                            @Bean(name = "Vehicle1")
                            Vehicle v1(){
                                return new createVehicle("BMW");
                            }

                        // Bean naming using "value" keyword:
                            @Bean(value = "Vehicle2")
                            Vehicle v2(){
                                return new createVehicle("Audi");
                            }

                        // Bean naming using Shortcut method:
                            @Bean("Vehicle3")
                            Vehicle v3(){
                                return new createVehicle("GWagon");
                            }

                Note: 
                        If bean components have same name, it will overwrite names and you will be able to access only one. 
                        The one which you can access is soly based on how spring processes.
                        ex.,
                            // projectConfig.java
                                @Bean(name = "v24")
                                Vehicle vehicle(){
                                    return new Vehicle("krunal", "BMW");
                                }

                                @Bean(name = "v24")
                                Vehicle vehicle2024(){
                                    return new Vehicle("2nd Class", "panda");
                                }

                            // main.java
                                System.out.println(context.getBean("v24", Vehicle.class));
                                --> It could be first or last bean compoent of same custom bean name.

            @Primary:
                        It decides default bean when user is trying to fetch Vehicle type bean.
                        ex., context.getBean(Vehicle.class);

                        @Primary annotation will make that Bean default bean.
                        ex.,
                            // projectConfig.java
                                @Bean
                                Vehicle vehicle(){
                                    return new Vehicle("krunal", "BMW");
                                }

                                @Primary
                                @Bean
                                Vehicle vehicle2024(){
                                    return new Vehicle("2nd Class", "audi");
                                }

                            // main.java
                                System.out.println(context.getBean(Vehicle.class));
                                --> Primary bean will be returned here.

                        Note: 
                            We can assign @Primary annotation to multiple Beans which result in NoUniqueBeanDefinitionException.

                            ex.,
                                // projectConfig.java
                                    @Primary
                                    @Bean
                                    Vehicle vehicle() {
                                        var veh = new Vehicle();
                                        veh.setName("Audi 8");
                                        return veh;
                                    }

                                    @Primary
                                    @Bean
                                    Vehicle vehicle2() {
                                        var veh = new Vehicle();
                                        veh.setName("bmw");
                                        return veh;
                                    }

                                // main.java
                                Vehicle v = context.getBean("audi", "Vehicle.class");

                                --> result in exception

                        NOTE:

                            ex.,
                                // projectConfig.java
                                    @Primary
                                    @Bean("audi")
                                    Vehicle vehicle() {
                                        var veh = new Vehicle();
                                        veh.setName("Audi 8");
                                        return veh;
                                    }

                                    @Primary
                                    @Bean("bmw")
                                    Vehicle vehicle2() {
                                        var veh = new Vehicle();
                                        veh.setName("bmw");
                                        return veh;
                                    }

                                // main.java
                                Vehicle v = context.getBean("audi", "Vehicle.class");

                                --> getContext() will look for only Vehicle bean whose name is "audi". As a result, it won't thorw exception because only one bean found with "audi" name.

                                if we found multiple bean with "audi" name, it will resturn @primary annoted Vehicle bean.

                                NOTE:
                                    if you have beans with "audi" names and mistakenly assign @Primary to multiple beans. it will throw NoUniqueBeanDefinitionException.

            @Component:
                        in real world to avoid writing @bean for all class; we write @component Annotation on class definition.

                        NOTE:
                            Spring will automatically create a single bean. (as part of Singleton bean scope)
                            To create more beans of same class, we need to use @CompoentScan in config file.

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:
                                }

                            // productConfig file
                                @ComponentScan(com.kpriyadarshi.beans);  --> this will scan all files from "Beans" folders.
                                public class ProjectConfig {
                                    ... empty file - as bean will be created with @CompoentScan ...
                                }

                            result -> when we run method. it will print Null for vehicle name. As we haven't assign value.

            @ComponentScan:
                        Spring has default feature to scan components where @Configuration or @SpringBootApplication is mentioned.
                        But when @Component is used we need to use @ComponentScan so that we know which beans to create.
                        
                        We need to include in a file where beans are created. Generally we mention this inside Config files.

                        ex.,
                            //productConfig.java
                                @ComponentScan(basePackage= "com.example.beans")
                                class productConfig(){
                                    ... methods to create beans ...
                                }

                        ComponentScan has more parameters...
                            @ComponentScan(
                                basePackage = "com.example.beans",
                                includeFilters = ...,
                                excludeFilters = ...
                            )

            @PostConstruct:
                        Executes when bean is created but constructor execute first.
                        NOTE:
                            First class's constructor is initialized. and after that @PostConstruct is executed.
                            -> If B is child class of A then first A's constructor will execute then B's constructor will execute after that A's @PostConstruct and B's @PostConstruct execute.

                        It is used to ensure custom configuration and logic has been implemented before the execution it is used.                       

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:

                                    @PostConstruct
                                    public void init(){
                                        this.name = "Honda";
                                    }
                                }

                            Result -> It will assign "honda" name to Vehicle class. else it will show null value when we try to print name of it.

            @PreDestroy:
                        Executes automatically when bean is being destroyed by spring framework.
                        Used to disconnect database, close file, Release a source etc.

                        NOTE: To use @PreDestroy annotation, we need to close ApplicationContext.

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:

                                    @PreDestroy
                                    public void destroy(){
                                        System.out.println("Closing Vehicle bean: " + this.name + "!");
                                    }
                                }

                            // Main.java
                                public static void main(String[] args) {
                                    var context = new AnnotationConfigApplicationContext(ProductConfig.class);
                                    -- use below line to execute @PreDestroy annotation:
                                    context.close();
                                }
                            
                            Result: It will execute @PreDestroy methods.

Hardcorded dependency/ Thight Coupling :: 
                        Vehicle class manually assigned to Person class in the configuration file. 
                        Doing so create Manual and TIGHTLY COUPLING.
                            ex.,
                                // productConfig.java
                                    @Configuration
                                    public class ProjectConfig {

                                        @Bean
                                        public Vehicle vehicle() {
                                            Vehicle veh = new Vehicle();
                                            veh.setName("Audi 8");
                                            return veh;
                                        }

                                        @Bean
                                        public Person person() {
                                            Person person = new Person();
                                            person.setName("John");
                                            person.setVehicle(vehicle()); // Manually setting dependency
                                            return person;
                                        }
                                    }

                        Now We want to add Model field (from CAR class which is subclass of Vehicle) to above code:
                            ex.,
                                // Create Car.java file with one field "modelName". 

                                // ProductConfig.java   
                                    @Primary
                                    @Bean
                                    public Vehicle createVehicle1(){
                                        var car = new Car();
                                        car.setModelName("i3");
                                        car.setName("BMW");
                                        return car;
                                    } 

                        Here, we need to change whole createVehicle1() method. 
                        Just imagine if we have x5 methods then we need to change entire ProductConfig.java file.

Wiring beans/ Loose Coupling   ::
                Remember, with one constructor we do not need to use @Autowired. It is optional and it will consider a dependency between both beans.

                Wiring beans using Method parameters: 
                        { Not a Good way to wire components as when change occures, We have to make changes everywhere. }
                            
                            In productConfig file, we will have person() method. 
                            Where we will use setVehicle() method from Person class and pass existing vehicle method from "productConfig" file.
                            ex., 
                                public Vehicle veh_Method(){
                                    Vehicle v = new Vehicle();
                                    v.setName("1k");
                                    return v;   
                                }

                                public Person person_Method(){
                                    Person p = new Person();
                                    p.setVehicle(veh_Method());  // method name is passed as parameter.
                                    return p;
                                }

                            NOTE:
                                ->  Instead of creating Vehicle bean for veh_method and person_method, Spring as default behaviour creates one Vehicle bean and give them. 
                                    You can use print statement in both constructors to validate above statement.
                                ->  We won't face any ambiguity as we are passing method name inside person method.

                Wiring beans using method calls:
                            Here, we will pass parameter "Vehicle veh_Temp". and everything is wired by spring. 
                            ex.,
                                public Person person_Method(Vehicle veh_Temp){
                                    Person p = new Person();
                                    p.setVehicle(Vehicle veh_Temp);  // instead of passing method name, we are passing object.
                                    return p;
                                } 

                            NOTE: As auto wiring is done by spring, we might face ambiguity if we have 2 beans with same data type.
                                    To avoid, we can use @Primary annotation.
                                    or @Qualifier("name_of_bean") annotation.                                    
                                    or It will match with the name given on parameter inside class and name given on configProduct file.

                                    ex.,
                                        class person{
                                            
                                        }

                Wiring beans using @Wiring annotation   : 
                                @Wiring annotation can be placed on bean class OR Setter method.

                                NOTE: There is a limitation that a bean variable can't be final. Because value is yet to assign.

                                ex.,
                                    @Component
                                    class Person{
                                        priavte final String name = "Krunal";

                                        @Autowired
                                        priavte Vehicle veh;

                                        @Autowired
                                        public void setVehicle(Vehicle vehicle) {
                                            this.vehicle = vehicle;
                                        }
                                    }

                                @Wiring annotation goes well with @Component because it will automatically wire vehicle to person object.
                                since @component does allow to create multiple instance we will not face ambiguity.

                                Exception is thrown if bean does not exist.

                                ex.,
                                    // only add @autowire to variable in Person() class. if we do not do that vehicle will be NULL for person object.

                                NOTE:
                                    We can trun off "@autowire(required = false)" to avoid exception if bean not found and assign NULL value to it.
                                    Also, we can not use final keyword with @autowired variable.
                 
                Wiring beans using @Wiring on constructor   :
                                To use final keyword for bean variable, we have to implement this method and it's accepted for production.

                                Use it with constructor:
                                ex.,    
                                    public class Person{
                                        priavte final Vehicle veh;

                                        @Autowired
                                        public Person(Vehicle veh){
                                            this.veh = veh;
                                        }
                                    }

                                NOTE:
                                    ->  you can't use default/ zero parametered constructor. as vehicle variable expect value.
                                    ->  @Qualifier can't be used with @Autowire but can be used inside parameter:
                                        ex.,
                                            // Runtime error:
                                                @Autowire
                                                @Qualifier ---> can not be used here wit constructor.
                                                public Person(Vehicle veh){
                                                    ... code ...
                                                }

                                        ex., 
                                            // Works:
                                                @Autowire
                                                public Person( (@Qualifier "Vehicle1") Vehicle veh){
                                                    ... code ....
                                                }

                                    ->  if class has only one constructor, we don't need to write @autowired as it will applied default. but make sure it is not default constructor with 0 parameter.

                                    ex.,
                                        public class Person{
                                            private final Vehicle veh;

                                            ---- writing @autowire is optional ----
                                            public Person(Vehicle veh){
                                                this.veh = veh;
                                            }
                                        }

                Autowiring with multiple Beans of same type :
                                        Spring will try to match Beans with same type. If type is Vehicle then it will try to find same type Bean. 

                                        If multiple is found, it will try to match parameter name but this way has less readibility as anything can be used as parameter so it is not adviced to use.

                                            ex.,                                                
                                                // ProductConfig file
                                                    @Configuration
                                                    class productConfig{
                                                        public Vehicle v1(){
                                                            ...
                                                        }

                                                        public vehicle v2(){
                                                            ...
                                                        }

                                                        @Primary
                                                        public vehicle v3(){
                                                            ...
                                                        }
                                                    }

                                                
                                                // Person.java
                                                    Class Person{
                                                        private final Vehicle veh;

                                                        @Autowire
                                                        public Person(Vehicle v1){
                                                            ... ...
                                                        }
                                                    }

                                                    RESULT: 
                                                        Spring will try to find same type bean but here 3 beans are found. {v1, v2, v3}. so spring will try to match with parameter name in constructor with name of vehicle method from config file.

                                                        As V1 method from config file matches it will show value as per v1.

                                                        If variable name did not match with any method from config file, it will choose @Primary bean.

                                                        OR you can use @Qualifier in constructor.
                                                        ex.,
                                                            // Person.javaClass 
                                                                Person{
                                                                    private final Vehicle veh;

                                                                    @Autowire
                                                                    public Person(@Qualifier("v1") Vehicle veh){
                                                                        ... ...
                                                                    }
                                                                }

Bean Scope (Part 1):
        - Singleton Bean (Default)
        - Prototype Bean
        - Request
        - Session
        - Application

        Syntex -->   " @Scope(BeanDefinition.SCOPE_PROTOTYPE) "

            Singleton (Default) ::
                            Singleton instantiation is default way Where same object is returned for Bean reference. 
                            Singleton Bean have Eager and Lazy concept for Bean creation.

                            Flaw/ Disadvantage -> 
                                When two users tries to access same data, it will create "RACE CONDITION". Where final value depends on last applied changes. It occurs for tread process.
                                ex.,
                                    We have one hashtable. here user1 and user2 tried to change value of key "animal". User1 changed value to "lion" but other changed to "cat". But value of "animal" depends on which thread arrived at last.

                            ex.,
                                HERE single bean "Vehicle" is accessed by V1 and V2 objects. If you print address of object it will same.

                                // Config file:
                                    class productConfig{
                                        @Bean
                                        public Vehicle vehicle(){
                                            return new Vehicle();
                                        }
                                    }

                                // main file:
                                    Vehicle v1 = context.getBean(Vehicle.class);
                                    System.out.println(v1.toString() + " --------------");

                                    Vehicle v2 = context.getBean(Vehicle.class);
                                    System.out.println(v2.toString() + " --------------");
                                    
                                    if(v2 == v1)
                                        System.out.println("same address");
                                    System.out.println(v2.hashCode());
                                    System.out.println(v1.hashCode());

                                    // Changing value on one object reflact on other object as same bean is used for both.
                                    v1.setName("no way");
                                    System.out.println(v2.toString());

            Prototype   ::
                            Prototype used to avoid RACE CONDITION occured by Singleton approach.
                            Here, New object is returned for each Bean reference.
                            Prototype bean does not have Eager instantiation concept because beans are created when needed. 

                            | Scenario                         | Person Scope | Vehicle Scope | Behavior                                                                 |
                            |----------------------------------|--------------|---------------|--------------------------------------------------------------------------|
                            | Both are prototype               | Prototype    | Prototype     | New Person and Vehicle instances are created for each getBean() call.    |
                            | Person: singleton, Vehicle: prototype | Singleton    | Prototype     | Person is shared, but each call to createVehicle() returns a new Vehicle.|
                            | Both are singleton               | Singleton    | Singleton     | Both Person and Vehicle instances are shared. Modifying one affects all references. |

                            ex.,
                                // Person is Singleton while Vehicle is Prototype:
                                    // Config file:
                                        @Configuration
                                        public class AppConfig {

                                            @Bean
                                            @Scope(BeanDefinition.SCOPE_PROTOTYPE)
                                            public Vehicle vehicle() {
                                                return new Vehicle();
                                            }

                                            @Bean
                                            public Person person() { // Singleton by default
                                                return new Person();
                                            }
                                        }

Singleton V/S Prototype ::
        > Singleton is default scope While Prototype is defined scope.
        > Singleton same objects for each bean reference while Prototype scope will return different object for each bean reference.
        > Singleton is used for immutable objects while Prototype used for Mutable object. 
        > singleton is commonly used scope while prototype is rarely used scope.

Singleton Eager & Lazy instantiation ::
                Eager instntiation is deafult behaviour of Spring. Where all beans are created at first by Spring. 
                This approach has one flaw that as all beans are created at first it might take time. Even those bean which we are going to use rarely. For example, Bean creation for "Deactivate my account". Which is rarely used in general.
                
                Hence Lazy instantiation was introduced to avoid bean creation at start. And create bean on demand.

                Eager V/S Lazy:
                    >   Spring's default behavior is Eager while Lazy is defined behaviour.
                    >   Eager will create all Beans at start. While Lazy will create bean on demand.
                    >   Eager will throw exceptions/errors before server start while we might face exceptions/errors using Lazy. ex., Lazy tries to create Bean during execution and it might not be found in IOC container and throws Exception.
                    >   Eager takes lots of space as all Beans are created and reduce Performance. Use of Lazy, maintains performance.
                    >   Eager is used in mostly cases but Lazy is used for rare cases.

                ex.,  
                    If we use @Lazy annotation, bean will created when are using getBean() method. we will see "Bean Creation" printed and after that "Vehicle is created".
                    Without @Lazy, spring will use default @Eagar annotation, where all beans are created. so we will see "Vehicle is created" before "Bean Creation".
                    
                    // Vehicle class:
                        class Vehicle{
                            public Vehicle(){
                                System.out.println("Vehicle is created.");
                            }
                        }
                    // config file:
                        class productConfig{
                            @Bean
                            @Lazy
                            public Vehicle veh(){
                                ...
                            }
                        }
                    // Main file:
                        var context = new ApplicationConfigApplicationContext(productConfig.java);
                        sout("-------- Bean Creation ------------")
                        Var vehicle = context.getBean(Vehicle.class);

AOP (Aspect Oriented Programming):
            Aspect is a logic/programming-code which contains cross-cutting concerns. Where Cross-cutting concerns includes performance monitoring logs, security, transcation management, logging etc,.

            AOP centralized this concerns in separated file. 
            ex.,
                To understand better, let's say we want to check execution start time, end time and total time taken of given Java file inside project.
                To do that, We can write single code. But what if we want to do this for java files inside Beans folder. Then we need to write this non-business code for all java files.  
                To reduce this, we use @Aspect file where we will create a method and write all non-business code. And access whenever we want ny simple adding "Advices" of AOP.

            Advantages of AOP:
                Modularization: Separates cross-cutting concerns from the main logic.
                Reusability: Allows you to reuse aspects across multiple modules.
                Clean Code: Reduces boilerplate code by moving repeated logic to a centralized aspect.
                Improved Maintenance: Easier to update or enhance cross-cutting concerns without modifying business logic.

            Function V/S AOP Aspect:
                AOP Aspect is some what same as Function. Where we define logic somewhere and later we call it where we need to use it. But Both are different.,
                >
                    Fuction follows Scatter Apporach. Function needs to be explicitly called where logic is required.
                    Aspect follows centralized Approach. Where logic, rules and everything is written on same file. We do not need to call them from Main method.
                >
                    Duplication for Function call. If we want to use logic in 10 places, we need to call function from each point.
                    Single Aspect call. Defined Point-cut Expression will make all call.
                >
                    Function creates Thighly Coupling.
                    Aspect creates Loosely Coupling.
                > 
                    Functions clutters the business logic. As we are writing non-business logic inside main method.
                    With AOP Aspect, all concerns are handled without touching Business logic.
                >
                    As business grow, developers might create new methods. And they might forget to add logging Functions to logic.
                    Because of Point-cut Expression, Aspect is applied to automatically and leave no room for human error. 

            NOTE: How to use Aspect inside Project:
                To use AspectJ in project.,
                >   We need to include Dependency inside POM.xml file.  
                >   In config file, enable AOP flag by @EnableAspectJAutoProxy. Which lets Spring know about AOP being used in project.
                >   In Aspect file, use @Component and @Aspect. 
                        @Aspect used to define class as an Aspect. Without it, Spring won't use advices (@Before, @After etc.,) or other Aspect logic.
                        @Component used to ensure class is a bean and it is eligible for Spring lifecycle.
                    
            AOP Jargons:
                Target Object   -   A class on which Aspect code will be intercept.
                Aspect          -   A class in which Aspect code is written.

                Advices         -   Advices are defined action on aspect methods. ex., @Before, @After, @Around
                Point Cut       -   AKA Point Cut Expression. Which specify where the advice should be applied. 
                Join Point      -   From Target Object, methods on which Advice will be applied to.

                ex.,
                    // Vehicle class:   "Vehicle.java" file
                        Class Vehicle{
                            private String name;

                            public void process(){
                                this.name += " @CanadianVersion";
                            }
                        }

                    // Aspect Class:    "LogginAspect.java" file
                        @Component
                        @Aspect
                        public class LogginAspect{
                            @Before("execution(* com.example.service.Vehicle.process(..)))
                            public void logging(){
                                System.out.println("---- Log: Accesing Vehicle ----");
                            }

                            @After("execution(* com.example.service.Vehicle.process(..)))
                            public void exitLogging(){
                                System.out.println("---- Log: Releasing Vehicle ----");
                            }
                        }

            ADVICE types:
                @Before             -   Befre the execution of method, Advice is applied.
                @AfterReturning     -   After the succesful execution of method, Advice is applied.
                @AfterThrowing      -   After Exception is thrown in target method, Advice is applied.
                @After              -   Advice is applied after the execution of method. (no matter exception is thrown or not.)
                @Around             -   Combination of @Before and @After.
                
            Point-cut expression syntex:
                    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
                    
                    NOTE:
                            package com.exmaple;
                            public class Solution{
                                public int checkMaxVal(int[] nums) thorw NullPointerException{
                                    ...     // implementation
                                }
                            }

                            --> modifiers-pattern is "public".
                            --> ret-type-pattern is "int".
                            --> declaring-type-pattern is "com.exmaple.Solution".   { It is combination of PackageName + ClassName.}
                            --> name-pattern is "checkMaxVal".  {It is method name.}
                            --> param-pattern is "int[]".   {It is parameter's data type.}
                            --> throws-pattern is "NullPointerException".

                    LEARN different TYPES OF EXPRESSION SYNTEX., 
                        Match all methods in package:
                            execution(* com.eazybytes.eazyschool..*.*(..))

                        Match all public methods from eazyschool package
                            execution(public * com.eazybytes.eazyschool..*.*(..))

                        Firt query: Match all methods in package
                        Second query: Match admin package's all method.
                        RESULT: Match all methods from both package.
                            execution(* com.eazybytes.eazyschool..*.*(..)) || execution(* com.eazybytes.admin..*.*(..))
                            execution(* com.eazybytes.eazyschool..*.get*(..)) && execution(public * *(..))

                        Match controller folder's ContactController class's all methods.
                            execution(* com.eazybytes.eazyschool.controller.ContactController.*(..))

                        Match displayMessage method with any number of parameters method but from ContactController class.
                            execution(* com.eazybytes.eazyschool.controller.ContactController.displayMessages(..))
                        
                        Match any Constructor of ContactController class. The constructor with 0 parameter or with multiple parameter.
                            execution(com.eazybytes.eazyschool.service.ContactService.new(..))

                        Match all methods who accept 2 parameter String and int from eazySchool package,
                            execution(* com.eazybytes.eazyschool..*.*(String, int))
                        
                        Match any method from eazyschool package but method must have a first parameter as String.
                        Matches can be updateContact(String name, int id) or updateContact(String email)
                            execution(* com.eazybytes.eazyschool..*.*(String, ..))

                        Match any method from eazySchool package but method last parameter of type string    
                        execution(* com.eazybytes.eazyschool..*.*(.., String))

                        Match any get* method.
                        It can be getContact(), getinfo(int id), getNmae(String firstName, String lastName)
                            execution(* com.eazybytes.eazyschool..*.get*(..))
                        
                        Match any methods with 0 signature value from eazySchool package.
                            execution(* com.eazybytes.eazyschool..*.*())






                        execution(String com.eazybytes.eazyschool.service.*.*(..))

            @Order: 
                Execution of Advice is random when multiple files implemented same Advice.
                We can give @Order(1), @Order(3)... for each Aspect file.

            Example., 
                MyAspect.java file:
                @Aspect
                @Component
                @Order(1)
                public class MyAspect {
                    private Logger logger = Logger.getLogger(MyAspect.class.getName());

                    @Around("execution(* com.example.beans.*.*(..))")
                    public void aroundExecution(ProceedingJoinPoint joinPoint) throws Throwable {
                        System.out.println("Around method execution in beans package --- start");
                        joinPoint.proceed();
                        System.out.println("Around method execution in beans package --- end");
                    }

                    @Before("execution(* com.example.beans.*.*(..))")
                    public void beforeExecution(){
                        System.out.println("---> Before method execution in beans package");
                        logger.log(Level.SEVERE, "Severe");
                        logger.log(Level.WARNING, "Warning");
                    }

                    @After("execution(* com.example.beans.*.*(..))")
                    public void afterExecution(){
                        System.out.println("---> After method execution in beans package");
                    }

                    @AfterThrowing(value = "execution(* com.example.beans.*.*(..))", throwing = "ex")
                    public void afterThrowExecution(JoinPoint joinPoint, Exception ex){
                        logger.log(Level.INFO, ex.getMessage());
                    }

                    @AfterReturning(value = "execution(* com.example.beans.*.*(..))", returning = "returnObj")
                    public void afterReturningExecution(JoinPoint joinPoint, Object returnObj){
                        logger.log(Level.INFO, "Successful Execution: " + returnObj);
                    }
                }

            Configuring Advices:
                    > Create Advice interface with @Retention Policy and @Target Runtime.
                    > Add @interfaceName on top of method inside class of "beans" folder.
                    > use "@annotation(com.example.interface.InterfaceName)" --> in aspect file.

                    example.,
                        // interfaces file -> LogAspect.java
                            @Retention(RetentionPolicy.RUNTIME)
                                @Target(ElementType.METHOD)
                                public @interface LogAspect {
                            }
                        
                        // 2nd step: 
                        Add @LogAspect - which is interface file name. On top of any method inside Bean class.
                        
                        // 3rd step: 
                        Aspect folder -> aspect.java file.   
                            @Before("@annotation(com.example.interfaces.LogAspect")
                            public void beforeExecution(){
                                logger.log(Level.INFO, "Annotation Interface.");
                            } 

Servlet     :
                Servlet is Server-side program that used to handle client request, process them and send dynamic response.
                ex.,
                    When you click on "Submit" button on form. The request will execute servlet on server side to validate entry and show message as response. 

Dispatcher Servlet  :
                Servlet inside spring known as "Dispatcher servlet". Which maintains all the URL mapping inside a web Application.
                
                In spring, responsibility of managing servlet goes to Spring framework instead of developers.

Create SpringBot project    :
                Go to "spring initializr" website. (https://start.spring.io/) --> used to generate web project skeleton based on required dependency.
                Configure details.
                Generate Project Zip file and extract it.
                From IDE, file -> new -> "IMPORT MODULE from source" select POM.XML file from extracted folder.
                Rebuilt project to install all dependencies.

                CREATE HELLO WORLD PROJECT:
                        Create HTML page inside resources -> static folder.
                        Create Controller for this html page -> 
                                        @Controller
                                        public class HomeController{
                                            @RequestMapping("home.html")
                                            public String displayHomePage(){
                                                return "home.html";
                                            }
                                        }
                
                NOTES:
                    @SpringBootApplication   -   
                                                It is Spring boot main class.
                                                PSVM{} use "SpringBootApplication.run(currentFileName.class, args) 

                                                It is made out of 3 annotations. {@EnableAutoConfiguration, @ComponentScan, @SpringBootConfiguration}

                    application.properties file   -
                                        Inside this file configure default setting setup by spring framework.
                                        ex.,
                                            server.port = 8077;     --> Assign port: 8077 to Spring application
                                            server.port = 0;        --> Assign any available port to application.
                                            server.servlet.context-path = "kp"      --> add "kp" to website path.  
                                                                    ex.,
                                                                        example.com/home --> redirects to Home page
                                                                        example.com/kp/home --> since context-path = "kp", we need to include "kp" inside web link.

                    debug = true            -
                                        Generates Autoconfiguration report on console.
                                        Which contains information about { positive_Matches, Negative_Matches, Exclusion, Unconditional_classes }        

ThymeLeaf Framework     :   
                    Thymelead has great integration with Spring MVC and Spring Security.
                    We can deploy Thymeleaf adn spring in one server. Not like {Spring + React/ Angular} project, where frontend stored at differentserver than backend files.

                    spring.thymeleaf.cache      :
                                        If cache is "true", thymeleaf will store compiled pages on every Server start and use that pages. Hence you won't see changes refalcted to pages when project is build again. 
                                        If cache is "false", thymeleaf will compile pages every built time. Great for development use.

                    NOTE:
                        This config works for thymeleaf pages, It won't work for backend files. We need to restart server everytime to see changes of backend file.

                    Thymeleaf Page Layouts      ::
                                        th: insert  :
                                                        Insert the child fragment to parent tag.
                                                        Parent's attributes are preserved and child fragment is inserted inside it.
                                        th: replace :
                                                        Replaces the entire parent tag with fragment.
                                                        Parent's attributes are replaced by child attributes.   

                                        NOTE:   content inside of parent will be removed and child fragment is placed instead.
                                            
                                            ex.,
                                                "HOME.html"     :   
                                                    <body>
                                                        <!-- Example with th:insert -->
                                                        <div th:insert="header::headerFragment" class="parent-insert" id="insert-id">
                                                            <p>Insert Example</p>
                                                        </div>

                                                        <!-- Example with th:replace -->
                                                        <div th:replace="header::headerFragment" class="parent-replace" id="replace-id">
                                                            <p>Replace Example</p>
                                                        </div>
                                                    </body>  

                                                "Header.html"   :  
                                                    <div th:fragment="headerFragment" class="child-header" id="child-id">
                                                        <h1>Header Content</h1>
                                                    </div>     

                                                OUTPUT          :
                                                    <body>
                                                        <!-- Example with th:insert -->
                                                        <!-- new child fragment is inserted inside parent -->
                                                        <div th:insert="header::headerFragment" class="parent-insert" id="insert-id">
                                                            <div th:fragment="headerFragment" class="child-header" id="child-id">
                                                                <h1>Header Content</h1>
                                                            </div> 
                                                        </div>

                                                        <!-- Example with th:replace -->
                                                        <!-- all attributes of parent is replaced. -->
                                                        <div th:fragment="headerFragment" class="child-header" id="child-id">
                                                            <h1>Header Content</h1>
                                                        </div> 
                                                    </body>

LOMBOK Library  :
            LOMBOK generates getter, setter, equals(), toString(), hashCode() methods & Constructors at compile time.
            It contains library such as @Getter, @Setter, @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor, @ToString, @EqualsAndHashCode, @Data 

            HOW TO USE LOMBOK:
                Add dependency of LOMBOK library in POM.xml file.

            @Slf4j  -
                Above annotation will remove declaration of logger in POJO file.
                ex.,
                    private static logger log = LoggerFactory.getLogger(Contact.class);
            @AllArgsConstructor -
                Creates a constructor using all available fields inside of class.
                ex.,
                    // HomeController.java
                    @AllArgsConstructor
                    public class HomeController{
                        public final String username;
                        @NotNull
                        public String name;
                        public int age;
                    }
                    // Constructor with all available fields inside class will be generated during compile time will be...
                    public HomeController(String username, String name, int age){   ... }
            @NoArgsConstructor  -
                Creates a default type constructor.
                ex.,
                    // HomeController.java
                    @NoArgsConstructor
                    public class HomeController{
                        public final String username;
                        @NotNull
                        public String name;
                        public int age;
                    }
                    // Default constructor will be generated during compile time will be...
                    public HomeController(){ }
            @RequiredArgsConstructor
                Creates a constructor with only @NotNull or final fields/variable inside of class.
                ex.,
                    // HomeController.java
                    @RequiredArgsConstructor
                    public class HomeController{
                        public final String username;
                        @NotNull
                        public String name;
                        public int age;
                    }
                    // Constructor with @NotNull and final field will be generated during compile time will be...
                    public HomeController(String username, String name){ }

SpringBoot DevTools     :
                    It is a dependency where Automatic restart & LiveReload happens for DEV environment. 
                    It will disable all cache of project so that components/pages/java file will be compiled for every build.

                    NOTE:
                        During built, DevTools won't be included to jav/war files. Making deployment to production easy because we might not need recompilation.

MVC pattern :
            MVC design is used to achieve loosely coupling.
                Model       -   It stores and manages the data from database.
                Controller  -   Bind Model & View together. And used to execute business logic inside.
                View        -   Ui and show data from controller.

Spring MVC Architecture (Interal flow)  :
            step 1: End user send http request to Server container. (Server container can be anything lets say TOMCAT server) 
            step 2: TOMCAT server accept http request and handover request to Dispather servlet.
            step 3: Dispather servlet will check with "Mapping Handler" to get method name and controller.
            step 4: Dispather servlet will invoke controller and its method.
                    After execution controller will return data and view to show the data inside.
            step 5: Dispather servlet finds view by "Resolver view" and render the data retrieved from controller. And send response.
            step 6: Server container will accept response from Dispater server and send it back to server.
            step 7: Server container will convert into HTTP response.
            step 8: Bowser will intercept HTTP response to show content.

URL path    :
            Absolute Path   -   
                        URL path starts with '/'. 
                        When resource file is in the same location. 
                        ex.,
                            Website URL :   https://example.com/folder/page
                            Componenet search   :   https://example.com/assets/css/style-starter.css

            Relative Path   -
                        URL has no '/' at start.
                        when resource file depends on the current folder location. If each html file has it's own CSS file.
                        NOTE: May cause problem using this method for subfolders.
                        ex.,
                            Website URL :   https://example.com/folder/page
                            Componenet search   :   https://example.com/folder/assets/css/style-starter.css

Controller      :
            Terms:
                    @RequestMapping(value = "/htmlPage")    -    Maps web requests to specific handler methods.
                    @RequestMapping(value = "/saveMsg", method = RequestMethod.POST)    -   Handle post request coming from a form with name = "saveMsg".
                    @PostMapping(value = "/saveMsg")    -   alternate of above method and handle POST request.     

            Create individual controller:
                ex.,
                    @Controller
                    public class HomeController {

                        @RequestMapping(value={"", "/", "home"})
                        public String displayHomePage() {
                            return "home.html";
                        }

                    }

            Create mapping Controller to avoid multiple creation of controller:
                ex.,
                    @Configuration
                    public class WebConfig implements WebMvcConfigurer {
                        @Override
                        public void addViewControllers(ViewControllerRegistry registry){
                            registry.addViewController("/courses").setViewName("courses");
                        }
                    }

            Data binding Process:
                            The name attribute of field from frontend is binded with @RequestParam of backend.
                                example.,
                                    // Front-end:
                                        <form th:action="@{/saveMsg}" method="post" class="signin-form">
                                            <input type="text" name="name" id="name" placeholder="Enter Your Name" />

                                    // Back-end:
                                        @PostMapping(value = "saveMsg")
                                        public ModelAndView saveMessage(
                                                @RequestParam String name,       // Matches name="name"
                                                @RequestParam String mobileNum,  // Matches name="mobileNum"
                                                @RequestParam String email,      // Matches name="email"
                                                @RequestParam String subject,    // Matches name="subject"
                                                @RequestParam String message     // Matches name="message"
                                        ){
                                            ... // code ...
                                        }

Query param V/S Path param  :
            Query param used for filter, sort or search. And it's format contains key-value pair after '?' in url.
            ex.,
                Filter products with 'electronic' category and sorting based on price Ascending.
                GET /products?category=electronic&sort=price
            
            Path param used to identify specific resource. Injected directly inside URL.
            ex.,
                Fetch product with id = 123.
                Get /products/123

Query params using @RequestParam   :
            getParameter() is a URL parameter that is used when a client or browser sends a request to a server.
            ex.,
                www.kpriyadarshi.ca/certificate?year=2021&order=asd
                Above link is with Query parameter.

            code configuration -
                Step 1 : Add queryParameter to any frontend link.
                    // Footer.html
                    <li><a th:href="@{/holidays(festival='true',federal='true')}">Holidays</a></li>
                Step 2 : Handle Query parameter from controller of the page. Make parameter non-required as it's used as filter.
                    // HolidayController 
                    @GetMapping(value = "/holidays/{display}")
                    public String displayHolidays(@RequestParam(required = false) boolean festival,
                                  @RequestParam(required = false) boolean federal,
                                  Model model){ ... }
                Step 3 : use th:if to hide or show <div> on frontend.
                    // holiday.html
                    <div class="col-lg-6" th:if="${festival} == true">

Path params using @PathVariable :
            Path params is.,
            ex., 
                www.kpriyadarshi.ca/certificate/all      

            Code configuration -
                Step 1 : Add Path param to the frontend side. Here, Path param is "all" string which will send to the backend side.
                    // Footer.html
                    <li><a th:href="@{/holidays/all}">Holidays</a></li>  
                Step 2 : Fetch Path param from backend side.
                    //  HolidayController.java
                    @GetMapping(value = "/holidays/{display}")    
                    public String displayHolidays(@PathVariable String display, Model model){ 
                        if(display != null && display.equals("all")){
                            model.addAttribute("federal", true);
                            model.addAttribute("festival", true);
                        }
                    }
                Step 3 : Use th:if to show or hide content at front end.
                    // holiday.html
                    <div class="col-lg-6" th:if="${festival} == true">

Spring Validation   :
            In html, we have required attribute to make field required during form submittion.
            ex.,
                <input type="text" name="name" id="name" placeholder="Enter your name" required>

            But it can be easily bypass by browser console where user will remove attribute by deleting it.
            Or by injecting javascript code. document.getElementById('name').removeArrribute('required');

            JAKARATA VALIDATION & HIBERNATE VALIDATION  :
                        jakarta.validation.constraints.*
                            @Digits
                            @Email
                            @Max
                            @Min
                            @NotNull    -   Return true for not null value. ex., "" (Empty string), " " (White space), "   ", "abc", " abc " 
                            @NotEmpty   -   Return true for at least one character. ex., " " (white space), "   ", "abc", " abc "
                            @NotBlank   -   Return true for at least one non-white space character. It is like performing trim() on value and check if it has character in it or not. ex., "abc", " abc " 
                            @Pattern
                            @Size

                        org.hybernate.validator.constraints.*
                            @CreditCardNumber
                            @Length
                            @Currency
                            @Range
                            @URL
                            @UniqueElements
                            @EAN
                            @ISBN

                        @NotNull V/S @NotEmpty V/S @NotBlank  :
                            | Example Value       | @NotNull | @NotEmpty | @NotBlank |
                            |---------------------|----------|-----------|-----------|
                            | null                | False    | False     | False     |
                            | "" (empty string)   | True     | False     | False     |
                            | " " (space)         | True     | True      | False     |
                            | "abc"               | True     | True      | True      |
                            | " abc "             | True     | True      | True      |
                            | "123"               | True     | True      | True      |
                            | "0"                 | True     | True      | True      |
                            | "true"              | True     | True      | True      |
                            | "false"             | True     | True      | True      |
                            | " " (3 spaces)      | True     | True      | False     |

            Implement Jakarta Validation on MVC project :
                        Step 1. Add model attribute onject contact to bind data with front end field.
                                ex.,
                                    @RequestMapping(value = "/contact")
                                    public String displayContactPage(Model model){
                                        model.addAttribute("contact", new Contact());
                                        return "contact.html";
                                    }
                        Step 2. Add th:object and th:field inside HTML page. This will bind field from HTML page to variable of POJO class.
                                NOTE: field name on HTML page and variable name on POJO class must be same to bind data. Else we need to use "name" attribute inside POJO class.
                                ex.,
                                    // contact.html
                                    <form th:action="@{/saveMsg}" method="post" h:object="${contact}">
                                        <input type="text" th:field="*{name}" required="true"/>
                                    </form>
                        Step 3. Add validation on POJO class. "Contact.java"
                                ex.,
                                    @NotBlank(message = "Enter name")
                                    private String name;
                        Step 4. When button on form page is pressed, pointer goes to controller of the page. 
                                Here we tell MVC to perform Validation and return Errors.
                                ex.,
                                    // ContactController.java
                                    @RequestMapping(value = "/saveMsg", method=POST)
                                    public String saveMessage(@Valid @ModelAttribute("contact") Contact contact, Errors errors){
                                        if(errors.hasErrors()){
                                            log.error(errors.toString());
                                            return "contact";
                                        }
                                        return "redirect:/home";
                                    }
                        Step 5. Show all errors to HTML page from controller class.
                                ex.,
                                    // contact.html
                                    <ul>
                                        <li class="alert alert-danger" role="alert" th:each="error: @{#fields.errors('contact.*')}"></li>
                                    </ul>

Custom Spring Validation    :
            To create Custom Validation, we need to create @interface and a class which implements @interface.

            Class must override isValid() method.
            where "ConstraintValidatorContext" is must required. Which can be used to get groups and define custom logic. And Payload can be used inside.
            And other parameter is datatype of value which is being validated.

            @interface:
                // PasswordValidator.java
                    @Constraint(validatedBy = PasswordStrengthValidator.class)      // Class which has custom logic for validation 
                    @Target({ElementType.FIELD})                                    // Targets - what needs to be validated
                    @Retention(RetentionPolicy.RUNTIME)                             // At Runtime it should execute
                    public @interface PasswordValidator {
                        String message() default "Please choose a strong password"; // Default error message incase no message defined in POJO class
                        Class<?>[] groups() default {};                             // groups defined here can be used inside java class by "context.getDefaultConstraintMessageTemplate().contains("Group1")" and define custom logic to it. like password max-length 6 for group1 but max-length for group2 is 10.
                        Class<? extends Payload>[] payload() default {};            // Used for logger or meta data. Create a class which extends Payload and define logger statement inside. Make sure to add it inside default{myExamplePayload.class} 
                    }
            Class which implement @interface:
                // PasswordStrengthValidator.java
                    public class PasswordStrengthValidator implements
                            ConstraintValidator<PasswordValidator, String> {
                        @Override
                        public boolean isValid(String passwordField,
                                            ConstraintValidatorContext cxt){
                            return passwordField != null && passwordField.length() > 5;
                        }
                    }
            POJO class:
                // User.java
                    public class UserDTO {
                        @PasswordValidator(message = "Password must be at least 8 characters, include one uppercase letter, one digit, and one special character.")
                        private String password;
                    }
                
Bean Scope (Part 2) :
            Request scope   -   
                        Spring creates new instance of bean for every HTTP request.
                        If user make 50 http_request to server, it will create a single bean for each http request. And these beans live for short duration and it's being collected by Garbadge collector. Hence avoid creating unneccessary request bean in application as it will it performance.
                        ex.,
                            Use request bean for passing credentials of users. As these details are not being stored in server after the use, request scope is perfect for this scenario.
            Session scope   -   
                        Spring creates new instance of bean for defined session time in server memory.
                        Session scoped bean lived for defined time. Hence avoid keeping too much infomation on session as it might hit performance.
                        Never store sensitive information inside Session scoped beans.
                        ex.,
                            userName that we show on multiple pages of application is defined as Session scope.
            Application scope   -   
                        Spering creates only one instance of bean for whole application run time.
                        Singlton and Application scope are so much similar but there are some edge cases, we want to use this other type of scope.
                        Avoid use of Application scoped beans unless needed as it also hit performance of web app. Instead of Application scoped bean, We can fetch data from database or caching. 
                        NOTE: Race condition can occur for Applicationscope.
                        ex.,
                            Each singlton scoped bean is created for each ApplicationContext but a web app can have multiple ApplicationContext.
                            While one Application scoped bean created for the whole web app. 

            NOTE:   
                Singleton & Prototype scope can be used inside web application or simple java code.
                Request/Session/Application scope can be used inside only web application as it works on HttpRequest.

SpringBoot Security :
            SpringBoot security brings Security related features to web app such as Authentication, Authorization etc.
            It protects webapp from Unauthorized access, CSRF, XSS, SQL Injection, Brute force attacks, Session hijacking etc.

            FLOW:   Request  Security Filter Chain  Security Rules  Controller

            Authentication V/S Authorization:
                ->  Authentication is used to check user's identity using id-password or OTP.
                    Authorization is used to check user's authority by checking their assigned role.
                ->  Authentication occurs before Authorization.
                ->  If Authentication fails it response 401 error message.
                    While Authorization fails we get 403 response.

            Implement SpringBoot Security   :
                Step 1.
                    Add dependency to POM.xml file. And load maven changes.
                    NOTE:   
                        After adding Springboot security, Authentication is implemented by default. Hence we will be redirected to login page initially. Where password is generated by spring security framework and it is available on Server Console.

                        We can create custom creds instead of spring security generates id-password on server console.
                        GENERALLY this method is used for POC but for PRODUCTION, we have to use Database/ OAUTH2 servers for id-password as there can be so many users.

                        Add id-password to "application.properties" file:
                            spring.security.user.name = krunal
                            spring.security.user.password = 12345678

                        This time password won't be generated on server console. And we can use id-password from application.properties file.

                Step 2.
                    Create securityConfig file:
                    ex.,
                        @Configuration
                        public class securityConfig{
                            @Bean
                            // Security Filter Chain are defined security rules for Http requests.
                            SecurityFilterChain defaultSecurityFilterChain(httpSecuirty http) throws Exception{
                                http.
                                    // Configure how http requests are authorized
                                    authorizeHttpRequests(
                                        // permit all incoming http requests
                                        auths -> auths.anyRequest().permitAll()
                                    )
                                    // Provides a default login page for users to log in. If a user is not authenticated.
                                    .formLogin(Customizer.withDefaults())
                                    // Enables basic Authentication for APIs.
                                    .httpBasic(Customizer.withDefaults());

                                return http.build();
                            }
                        }

            permitAll() -   
                        Accept all incoming http request. Used to allow access to the resource file CSS/JS/Assets.
            denyAll()   -   
                        Denies all incoming http request. Used for temporay retired APIs or for some testing purpose. 
                        When we try to access such denied resource, it will send "403 response".
            anyRequest()    -
                        Matches all incoming requests (global matcher/ catch-all rule).
                        ex.,
                            http.authorizeHttpRequests(authz -> authz
                                    .requestMatchers("/admin/**").hasRole("ADMIN") // Only ADMIN can access /admin/**
                                    .anyRequest().permitAll()                      // All other requests are allowed
                            );  
            requestMatchers()   -
                        Match specific pattern of http request.
                        ex.,
                            // Matches "http://localhost:8080/home" but does not match "http://localhost:8080" and send 403 response.
                            http.authorizeHttpRequests(authz -> authz
                                    .requestMatchers("/home").permitAll()        // only "/home" matched requests will have access/
                                    .anyRequest().denyAll()                      // not matching requests will be rejected and 403  response will be sent once user is logged in.
                            ); 

                            // In controller "", "/", "/home" path returns "home.html" string. so we need to include each request.
                            http.authorizeHttpRequests(auths -> auths
                                    .requestMatchers("/index", "/", "/home").permitAll() 
                                    .anyRequest.denyAll()
                            )

                            NOTE:
                                we can not use "" in requestMatchers as pattern can't be empty.
                                Hence we have to use "/index" pattern to match "" request.

                            // HolidayController has Path variable and url changes accroding to that.
                            ex., 
                                /holiday/all    -   to show all federal and festival holiday
                                /holiday/festival   -   to show all festival holiday
                                /holiday/federal    -   to show all federal holiday

                                http.authorizeHttpRequests(auths -> auths
                                        .requestMatchers("/holiday/**").permitAll() 
                                        .anyRequest.denyAll()
                                )
                        
                        NOTE:   
                            We need to give access to the public resource such as CSS file, Js file, assets folder. As Spring security, secure all component of web app.

                            Hence do this.,
                                    .requestMatchers("/assets/**").permitAll() 
            authenticated() -
                        A request will be accessible by authenticated users- those who are logged in.
                        ex.,
                            http
                                .authorizeHttpRequests(auth -> auth
                                    .requestMatcher("/home").authenticated()
                                )
                                .build();

            CSRF Token    :
                        CSRF is a token used to prevent attack such as cross-site request.
                        It is token gnereated by server and during each http request, client has to sent it with http request otherwise server will reject the request. 

                        By default, Spring security enables CSRF for all Http methods which can alter data like POST, DELETE, UPDATE etc. And also for login and logout action as they are state changin action.
                        But spring security is not enable for GET method.

                        Syntex:
                            // inlcude in login.html so Spring security and thymeleaf can handle all.
                            <input type="hidden" th:name="${_csrf.parameteName}" th:value="${_csrf.token}" />

                        http.csrf().disable()  -
                                    Used to disable CSRF for whole application. 
                                    ex.,
                                        http.csrf().disable();
                        http.csrf.ignoringRequestMatcher()  -
                                    Used to disable CSRF for specific action.
                                    ex.,
                                        ttp.csrf.ignoringRequestMatcher("/saveMsg");

                        NOTE: 
                            SpringSecurity has default behaviour in which CSRF is handle. It will send 403 response if invalid http request is receieved.
                            When you use ReactJS or AngularJS, developer have to handle CSRF but with thymeleaf is not needed as thymeleaf handle CSRF by detault.
                            ex.,
                                // Regular form submit action which result in 403 response as it is vulnerable to CSRF attack.
                                // home.html
                                <form action="/saveMsg"> </form> 
                                
                                // To avoid 403 response, You can disable it in config file by,
                                http.csrf().disable();
                                Or http.csrf(AbstractHttpConfigurer::disable);
                                or http.csrf(csrf -> csrf.disable());
                                
                                // But it increses the risk of CSRF attack.
                        
                        NOTE:
                            When CSRF is disable on config file. Spring stops generating and validating CSRF token.
                            As a result, attacker can take sessionId "JSESSIONID" from cookies which is maintained by the web container in the form of cookie.
                            Attackers can take this sessionId and show them as authorized peroson and inject JavaScript code to webApp.

            CSRF lifecycle  :
                        For data-manipulating (POST, DELET, UPDATE) or state-changing (LOGIN, LOGOUT) actions, the request first goes to the SecurityFilterChain.

                        If ignored/permitted, it proceeds to the controller.

                        If not permitted, it triggers authentication/authorization checks.

                        After passing checks, the controller processes the request and redirects as needed.

                        If controller has @Valid then it checks validation that is defined inside class file.

                        After the validation of controller, if service class is used. Pointer goes to service class and then data layer to save data.

            Store information in web app memory :
                        Create a method with return type "InMemoryUserDetailsManager" which object will store all user details like usernane, password, role etc.
                        ex.,
                            // SecurityConfig.java
                            @Bean
                            public InMemoryUserDetailsManager userDetailsService(){
                                // user 1
                                UserDetails admin = User.builder()
                                    .username("k")
                                    .password("1")
                                    .roles("ADMIN", "USER")
                                    .build();

                                // user 2
                                UserDetails user = User.builder()
                                    .username("p")
                                    .password("1")
                                    .roles("USER")
                                    .build();

                                return new InMemoryUserDetailsManager(user, admin);
                            }
.
Spring Security & thymeleaf :
            To load dynamic rendering to web app, this extra package used to fetch data such as user logged in or not, authorized or not etc.
        
            sec:authorize="isAnonymous()"   -   true if User is Anonymous.
            sec:authorize="isAuthenticated()"   -   true if User is logged in to the system.
            sec:authorize="hasRole("name")  -   true if string matches with User's role.
            sec:authorize="hasAnyRole('ROLE_USER', 'ROLE_ADMIN')"   -   true if user has any role from list.
            
            sec:authentication="name"   -   Displays the username of the authenticated user
            sec:authentication="autorities"   -   Displays the authorities (roles) associated with the currently authenticated user.
            sec:authentication="principal"  -   Displays the entire principal object (usually the user details object that contains username, roles, etc.).

            IMPLEMENTATION OF SPRING SECURITY & THYMELEAF:
                        Step 1: inlcude dependency inside POM.XML file                   
                            <dependency>
                                <groupId>org.thymeleaf.extras</groupId>
                                <artifactId>thymeleaf-extras-springsecurity6</artifactId>
                            </dependency>
                        Step 2: Add xlms: to your header.html file to use dynamic rendering.
                            // header.html  
                            <html lang="en" xmlns:th="http://www.thymeleaf.org"
                                xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity6">
                        Step 3: Use sec:authorize & sec:authentication attribute:
                            // header.html
                            <li class="nav-item" sec:authorize="isAnonymous()">
                                <a th:href="@{/login}" class="nav-link">LogIn</a>
                            </li>
                            <li class="nav-item" sec:authorize="isAuthenticated()">
                                <a th:href="@{/logout}" class="nav-link">logout</a>

Global Exception Handler   : 
            @ExceptionHandler used to handle exceptions during runtime of WebApp.

            NOTE:
                USE @ControllerAdvice(annotation = Controller.class) to apply global exception handler for controller only.
                For REST services, we might want to use @RESTControllerAdvice(annotation = RESTController.class)

            @ExceptionHandler can be used with one controller @Controller to handle any exception occured in the specific controller class.
            ex.,
                Here we are handling 2 exceptions thrown for HomeController with @ExceptionHandler:    
                // HomeController.java
                @Controller
                public class HomeController{
                    @RequestMapping("/home")
                    public String displayHomePage{
                        return "home.html";
                    }

                    @ExceptionHandler({
                        NullPointerException exception,
                        IOException exception
                    })
                    public ModelAndView handleException(RuntimeException ex){
                        .. code..
                    }
                }

            @ExceptionHandler can be used for all controller using @ControllerAdvice.
            ex.,
                // GlobalExceptionController.java
                @ControllerAdvice
                public class GlobalExceptionController{
                    // Parent class of all exceptions.
                    @ExceptionHandler(Exception.class)
                    public ModelAndView handleException(RuntimeException ex){
                        .. code..
                    }
                }

            ??? Why ModelAndView was used here?

H2Databse   :
            Wheneeer we start server, we need to create data schema and table. 
            Because when we terminate/restart server all the information have been lost and during start of server, new memory is initialized.

            It is used for Non-Production environment to avoid creation of SQL/oracle database instead focus on building and testing demo project quickly.

            IMPLEMENT H2DATABASE    :
                        step 1: Include dependency to POM.xml file.
                            code:
                                <dependency>
                                    <groupId>com.h2database</groupId>
                                    <artifactId>h2</artifactId>
                                    <scope>runtime</scope>
                                </dependency>
                        step 2: Add configuration to application.properties
                            code:
                                spring.datasource.url=jdbc:h2:mem:testdb
                                spring.datasource.driverClassName=org.h2.Driver
                                spring.datasource.username=sa
                                spring.datasource.password=
                                spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
                                spring.h2.console.enabled=true
                                spring.h2.console.path=/h2-console
                                spring.jpa.hibernate.ddl-auto=update
                                spring.jpa.show-sql=true
                        step 3: Access "h2console" but before that add permitAll() and CSRF friendly.
                            ex.,
                                http.csrf(
                                    csrf -> csrf.ignoringRequestMatcher(PathRequest.toH2Console())
                                )
                                .requestMatchers().permitAll(PathRequest.toH2Console());
                        step 4: Disabling Spring security when security trying to deal with frame component.
                            code:
                                http.headers(headersConfigurer -> headersConfigurer
                                        .frameOptions(frameOptionsConfig -> frameOptionsConfig.disable()));
                        step 5: Go to /h2-console link:
                            link:
                                http://localhost:8080/h2-console/
                        
                        NOTE:
                            For CSRF use PathRequest.toH2Console() method instead of using String "/h2console".
                            Else with the string "/h2console" will not work.

JDBC    :
            With JDBC there are lots of stpes to connect database.,

            Steps to access Database using JDBC:
                Load driver class
                Obtain a DB connection
                Obtain a statement suing connection object
                Execute the query
                Process the result set
                Close the connection

JDBCTemplate :
            Because of JDBCTemplate, we do not need to load driver class, create DB connection, catch exception and handle it etc.
            JDBCTemplate will take care of that and we can focus on creating business logic.
            JDBC is used as backend for Advance framework such as Spring Data, Hybernate etc.

            SAVING DATA TO DATABASE:
                        step 1.
                            Data goes from HTML page -> controller class -> service class -> Repo class 
                        step 2.
                            // contact.html
                            <form action="/saveMsg" method="post" class="signin-form" th:object="${contact}">
                                <input type="text" th:field="*{name}" placeholder="Your Name" class="contact-input" />
                        step 3.
                            // contactController.java
                            @Autowired
                            private final ContactService contactService;  

                            @RequestMapping(value = "/saveMsg",method = POST)
                            public String saveMessage(@Valid @ModelAttribute("contact") Contact contact, Errors errors) {
                                if(errors.hasErrors()){
                                    log.error("Contact form validation failed due to : {}", errors.toString());
                                    return "contact.html";
                                }
                                contactService.saveMessageDetails(contact);
                                return "redirect:/contact";
                            }
                        step 4.
                            // ContactRepository.java
                            @Repository
                            public class ContactRepository {
                                @Autowired
                                private final JdbcTemplate jdbcTemplate;

                                public int saveContactMsg(Contact contact){
                                    String sql = "INSERT INTO CONTACT_MSG (NAME) VALUES (?)";
                                    return jdbcTemplate.update(sql,contact.getName());
                                    }
                            }
            
            QUERY DATA FROM DATABASE AND SHOW INSIDE HTML PAGE: 
                        flow: 
                            When user load "/messages.html" page, the pointer goes to SecurityConfig file.
                            And checks if current user has permission/permit for current HttpRequest.
                            If user has access, pointer goes to controller of it. And checks if modelAndView assign it or not.
                            Here, it is getMapping request.
                            So controller will call service and service call Repository class and fetch data from database.
                            Here we need to map data from database column to object field using Mapper.
                        
                        step 1.
                            Create a Mapper to bind data with column to object fields:

                            NOTE: 
                                Mapper class has 2 parameters:
                                    ResultSet is data retrieved from SQL query.
                                    rowNum shows which row in the result set is currently being processed.
                            
                            // ContactRowMapper.java
                            public class ContactRowMapper implements RowMapper<Contact> {
                                @Override
                                public Contact mapRow(ResultSet rs, int rn) throws SQLException {
                                    Contact contact = new Contact();
                                    contact.setContactId(rs.getInt("CONTACT_ID"));
                                    contact.setName(rs.getString("NAME"));

                                    System.out.println("Row Number: " + rowNum);
                                    return contact;
                                }
                            }

                            NOTE: 
                                We can skip creating Mapper class if field name from SQL column is exactly like variable name inside class.

                                Update Repository class and use BeanPropertyRowMapper.newInstance(className.class) which will create RowMapper.
                                // ContactRepository.java
                                @Repository
                                public class ContactRepository{
                                    @Autowired
                                    public JdbcTemplate jdbcTemplate;

                                    public List<Contact> getAllContacts(){
                                        String sql = "SELECT * FROM contact";
                                        return jdbcTemplate.query(sql, new BeanPropertyRowMapper.newInstance(Contact.class));
                                    }
                                }
                        step 2.
                            Use Mapper and jdbc.query() to fetch data from database.

                            NOTE:
                                jdbcTemplate has 3 parametes:
                                    Sql query in string format
                                    PreparedStatementSetter() which is used to set value for ? in query
                                    Mapper to bind data with database column data to class field

                            // ContactRepository
                            @Repository
                            public class ContactRepository {
                                @Autowired
                                private final JdbcTemplate jdbcTemplate;

                                public List<Contact> findMsgsWithStatus(String status){
                                    String sql = "SELECT * FROM contact_msg WHERE status = ?";
                                    return jdbcTemplate.query(sql, new PreparedStatementSetter() {
                                        @Override
                                        public void setValues(PreparedStatement ps) throws SQLException {
                                            ps.setString(1, status);
                                        }
                                    }, new ContactRowMapper());
                                }
                            }

                        step 3.
                            Service object to perform business logic and call above Repository method to fetch data:
                            ex.,
                                // ContactService.java
                                public List<Contact> findMsgsWithOpenStatus(){
                                    List<Contact> contactMsgs = contactRepository.findMsgsWithStatus(EazySchoolConstants.OPEN);
                                    return contactMsgs;
                                }
                        
                        step 4.
                            Controller class to set view-model or redirect.
                            In this case, we will set model and view to show data to getMapping request.

                            ex.,
                                // ContactController.java
                                @RequestMapping(value = "/displayMessages", method = RequestMethod.GET)
                                public ModelAndView displayMessage(){
                                    List<Contact> contactMsgs = contactService.findMsgsWithOpenStatus();
                                    ModelAndView modelandview = new ModelAndView("messages.html");
                                    modelandview.addObject("contactMsgs", contactMsgs);
                                    return modelandview;
                                }

                        step 5.
                            Show data to html page:
                            ex.,
                                // messages.html
                                <tr th:each="msg: ${contactMsgs}">
                                    <td th:text="${msg.name}"></td>
                                    <td><a th:href="@{/closeMsg(id=${msg.contactId})}" class="btn btn-style btn-style-3">CLOSE</a></td>
                                </tr>

NamedParamaeterJDBCTemplate :
            instead of using '?', we are providing field name in NamedParamaeterJDBCTemplate.
            It just provide more readibility to code than JDBCTemplate.

            ex.,
                // Contact.java
                @Data public class Contact{
                    public String name;
                }  

                // ContactRepository.java
                @Repository
                class ContactRepository{
                    @Autowire
                    private NamedParamaeterJDBCTemplate namedParamaeterJDBCTemplate;

                    public int saveContact(Contact contact){
                        String sql = "INSERT INTO contacts (name) values (:name)";
                        // map parameters
                        SqlParameterSource parameters = new SqlParameterSource().addValue("name", contact.getName());

                        return namedParameterJdbcTemplate.update(sql, parameters);
                    }
                }

AWS RDB :
            Perform AWS setup and create RDB    -
                        user name   :   admin
                        password    :   12345678
            Create inBound rules    -
                        type    :   MySQL/Aurora
                        source  :   ipv4/ ipv6
            Add Dependency to Maven project -
                        MySQL driver dependency
                        ex.,                     
                            <dependency>
                                <groupId>com.mysql</groupId>
                                <artifactId>mysql-connector-j</artifactId>
                                <scope>runtime</scope>
                            </dependency> 
            MySQL database setup    -
                        Schema.sql, data.sql add these two files and execute 'em.
            Add config file -
                        spring.datasource.url = jdbc:mysql://spring.cp4gaege6w9w.us-east-2.rds.amazonaws.com
                        spring.datasource.username = admin
                        spring.datasource.password = 12345678

                        NOTE:
                            url is "jdbc:mysql://" + AWS's Endpoint + DB name from MySql 
                            username and password are from initial AWS RDB Database setup.

Spring DATA :
            It is spring framework which simplifies data access for application. In result, developers do not need to write extra code to access these data from DB.
            There are many modules like.,
                Spring JDBC,
                Spring DATA JPA,
                Spring DATA REST., etc

            Hierarchy of Spring Data Interface:
                Repository ---> CrudRepository ---> ListCrudRepsitory ---> JPARepository
                Repository ---> PagingAndSortingRepository ---> ListPagingAndSortingRepsitory ---> JPARepository

                ex.,
                     Repository
                               |
                        CrudRepository
                       /             \
      ListCrudRepository    PagingAndSortingRepository
                       \             /
                       JpaRepository

Spring JDBC :
            Spring JDBC is limited ORM (Object Related Mapping) framework.
            It is small version of Spring DATA JPA.
            It does not offer caching, lay loading and many features that JPA provides.

ORM (Object Related Mapping)    : 
            Map tables to Classes.
                Columns map to fields (attributes) in the class.
                Rows map to Object of class.
            Managing Relationship 
                ORM handles all One-to-one, One-to-many, many-to-many
            Automatic SQL query generation
            Session Management
            Persistence Context

Optional<> object   :
            Optional object is a safer way to deal with not null values.
            When we try to use method on null values, we get NULLPOINTEREXCEPTION.
            Hence, we need to null value before processing further.
            ex.,
                public boolean isUpdated(String id, String FirstName){
                    Contact contact = Repository.findById(id);
                    // contact can be null:
                    if(contact == null)
                        return false;

                    contact.setFirstName(FirstName);
                    Contact result = Repository.save(contact);
                    // if database could not save data for some reason it could return null value as it failed to update value of contact obejct.
                    return result != null;
                }
            
            To safer way to deal NULL values, we can use Optional.ifPresent() with Optional.get().
            Optional.ifPresent()    -
                        Returns True if value is present else return false;
            Optional.get()  -
                        Returns the object saved inside Optional object. 
                        initially we are passing an object when declaring Optional object.
                        Optional<Contact> contact = new Optional<>();
                        contact = Repository.findById(id);

            ex.,
                public boolean isUpdated(String id, String FirstName){
                    Contact contact = Repository.findById(id);
                    
                    if(contact.ifPresent()){
                        contact.setFirstName(FirstName);
                        Contact result = Repository.save(contact);
                        // if saved succesful returns True else False.
                        return result != null;
                    }
                    
                    // if Null is return during fetch operation of findById() method.
                    return false;
                }

                OR YOU CAN USE LAMBDA FUNCTION:
                public boolean isUpdated(String id, String FirstName){
                    Contact contact = Repository.findById(id);
                    
                    contact.ifPresent( con ->{
                        contact.setFirstName(FirstName);
                        Contact result = Repository.save(contact);
                    });

                    return contact.ifPresent;
                }
               
Spring DATA JPA :
            @Entity  -
                    Used to define relationship between a java class and a database table.
                    
                    Spring JPA tries to match Class name and Table name, inorder to bind data.
                    This can be done by ignoring casing and "_" character which is used in SQLdb frequently for Table or Column name.

                    NOTE:
                        Spring JPA has default behaviour of matching class and table (Field and Column) by trying to match names.
                        ex 1.,
                            Class name = "Contact"
                            Table name = "contact"
                                These will match as Spring JPA will ignore sensitive casing.
                            
                        ex 2.,
                            Field name = "contactId"
                            Column name = "contact_id"
                                These will match as '_' and sensitive casing will be ignored.

                        ex 3.,
                            Class name = "Contact"
                            Column name = "contact_id" 
                                These will not match. So we need to use @Table(name = "Contact_id") in java file.
                        
                        ex 4.,
                            Field name = "email"
                            Column name = "email_id"
                                These will not match. So we need to use @Coulmn(name = "email_id") in java file.

            @MappedSuperClass   -
                    It is not a table but provide fields to child class. As BaseEntity has fields like createdBy, lastUpdatedBy etc., which are common for each table inside Database.

            @Id -   
                    To set field as Primary key.

                    NOTE:   
                        To auto populate field as per Database generation method, we need to use @GeneratedValues() and @GenericGenerator().

                        @GeneratedValues() defines ID generation rule and Generator's name that needs to be used.
                        @GenericGenerator() defines Strategy based on database to generate IDs. 

                        CODE:
                            @Id
                            @GeneratedValues(strategy = GenerationType.AUTO, generator = "native")
                            @GenericGenerator(name = "native", strategy = "native")
                            @Column
                            private String contactId;

            @Column -
                    When column name and class variable name is not matching add @Column on top of field declaration.

            @Table  -
                    When table name and class name is not matching add @Table on top of class declaration.

            @Transient  -
                        Tells spring, not to include these class fields to any database related operations.
                        ex.,
                            class person{
                                @PasswordValidator
                                private String password;

                                @Tramsient
                                private String confirmPassword;
                            }

            Step 1  -   In MainApplication file, scan Repository and Model/entity to use Spring DATA JPA.
                        ex.,
                            // Main SpringBoot application file:
                                @SpringBootApplication
                                @EnableJpaRepositories("com.eazybytes.eazyschool.repository")
                                @EntityScan("com.eazybytes.eazyschool.model")
                                public class EazyschoolApplication {
                                    public static void main(String[] args) {
                                        SpringApplication.run(EazyschoolApplication.class, args);
                                    }
                                }

            Step 2  -   Data mapping of Fields and Columns
                        By using @Entity on top of class table.
                        Use @Table, @Column to match name with fields and columns.

                        For BaseEntity class use @MappedSuperClass so that we can use inside our POJO class.

                        For Primary Key, use @Id
                        And for AUTO_INCREMENT, use @GeneratedValue(strategy = GenerationType.IDENTITY); Which generates Id Automatically based on MySQL's native ID generation method.

                        ex.,
                            // Any class with id AUTO_INCREMENT
                            @Id
                            @GeneratedValue(strategy = GenerationType.IDENTITY)
                            @Column(name = "contact_id")
                            private int contactId;


                        For Primary Key, use @ID and @GeneratedValues() & @GenericGenerator(). Which is deprevated method and no longer in avaiable to use by Spring framework.
                        ex.,
                            // Any class with id AUTO_INCREMENT
                            @Id
                            @GeneratedValue(strategy= GenerationType.AUTO,generator="native")
                            @GenericGenerator(name = "native",strategy = "native")
                            @Column(name = "contact_id")
                            private int contactId;

            Step 3  -   Implement Repository inside Repository class such as CrudRepository, ListCrudRepsitory etc.

                        NOTE:
                            Repository interface expect 2 parameters:
                                -> Class name 
                                -> Datatype of Primary Key
                            
                                ex.,
                                    implements CrudRepository<Contact, String>
                                        where Contact class implement this method and Primary key has String/varchar data type.

                        ex.,
                            // Class ContactRepository

                                @Repository
                                Class ContactRepository implements CrudRepository<Contact, Integer>{
                                    ...
                                }

            Step 4  -   Define Custom Query Methods inside Repository files. If needed.

            Step 5  -   Implment Query logic inside Service class:

                        ex.,
                            // ContactService.java
                            @Slf4j
                                @Service
                                public class ContactService {
                                    @Autowired
                                    private ContactRepository contactRepository;

                                    public boolean saveMessageDetails(Contact contact){
                                        boolean isSaved = false;
                                        contact.setStatus(EazySchoolConstants.OPEN);
                                        Contact savedContact = contactRepository.save(contact);
                                        if(null != savedContact && savedContact.getContactId()>0) {
                                            isSaved = true;
                                        }
                                        return isSaved;
                                    }

                                    public List<Contact> findMsgsWithOpenStatus(){
                                        return contactRepository.findByStatus(EazySchoolConstants.OPEN);
                                    }

                                    public boolean updateMsgStatus(int contactId, String updatedBy){
                                        boolean isUpdated = false;
                                        Optional<Contact> contact = contactRepository.findById(contactId);
                                        contact.ifPresent(contact1 -> {
                                            contact1.setStatus(EazySchoolConstants.CLOSE);
                                        });
                                        Contact updatedContact = contactRepository.save(contact.get());
                                        if(null != updatedContact && updatedContact.getUpdatedBy()!=null) {
                                            isUpdated = true;
                                        }
                                        return isUpdated;
                                    }
                                }

            Step 6  -
                        Optional Setting only if you want to see Generated Query by Derived Query Methods in JPA.
                        "spring.jpa.show-sql" used to show SQL query inside Server console.
                        "spring.jpa.properties.hibernate.format_sql" used to format those sql query as the will be printed in single line by default.
                        
                        example.
                            // application.properties
                            spring.jpa.show-sql= true
                            spring.jpa.properties.hibernate.format_sql= true

CUSTOM QUERY METHOD :
            We can find a row by using FindByName("krunal") but sometime we need complex query to retrieve records from database. 

            For that, Derived Query Methods are used:
                        Introducer clause   -
                                    find    :
                                                Used to retrieve data from DB.
                                                ex.,
                                                    List<User> findByFirstName(String firstName);
                                    read    :
                                                Used to read data from DB. 
                                                'read' and 'find' are same.
                                                But in special senario where we do not have record in DB and want to handle data as an exception.
                                                ex.,
                                                    List<User> readByFirstName(String firstName);
                                    query   :
                                                Create custom query to solve complex query.
                                                ex.,
                                                    @Query("SELECT u FROM User u WHERE u.firstName = ?1")
                                                    List<User> queryByFirstName(String firstName);
                                    count   :
                                                Counts records retreieved by query.
                                                ex.,
                                                    long countByFirstName(String firstName);
                                    get :
                                                Used to retrieve single record.
                                                ex.,
                                                    User getById(Long id);
                                    Distinct    :
                                                Used to fetch distinct records.
                                                ex.,
                                                    List<User> findDistinctByFirstName(String firstName);
                        Criteria clause -
                                    Or  :   
                                    And :

            exercise:
                findDistinctFirstNameAndLastName(String firstName)
                    SELECT Distinct u.FirstName, u.lastName FROM user u WHERE u.firstName = ?1;
                findByLastNameAndFirstName(firstName, SecondName)
                    SELECT * FROM user AS u WHERE u.firstname = ?1 AND u.lastname = ?2;
                findByEmail(emailAddress)
                    SELECT * FROM user AS u WHERE u.email = ?1;                     
                findByFirstNameOrderByLastNameAsc(String firstName)
                    SELECT u FROM User u WHERE u.firstName = ?1 ORDER BY u.lastName ASC;
                findByEmailContaining(String partOfEmail)
                    SELECT u FROM User u WHERE u.email LIKE ?1;
                findByAgeBetween(int minAge, int maxAge)
                    SELECT u FROM User u WHERE u.age BETWEEN minAge AND maxAge;
                findAgeGreterThan(int age)
                    SELECT u FROM user WHERE u.age > ?1;
                findByFirstNameNot(String firstName)
                    SELECT u FROM user WHERE u.firstName <> ?1;

CUSTOM QUERY WITH JPA   :
            @Query / JPQL (Java Persistence Query Language) :
                        JPQL is similar platform independent and objet Oriented query language.
                        JPQL query is similar to SQL query.
                        ex.,
                            @Query("SELECT C FROM customer c WHERE c.contactId = ?1 ORDER BY c.createdAt DESC)
                            List<Customer> findByIdOrderByCreatedAtDesc(long id);

                        example.,
                            // contactRepository.java
                            Page<Contact> findByStatus(String fieldName, Pageable pageable);

                            ---> Here Spring will create its own query and executes. 
                            ---> But if you do not want and wanted to create custom query. Use it by using @Query annotation with JPQL query inside.

                            // Updated contactRepository.java
                                @Query("SELECT c FROM contact WHERE c.status = :status")
                                Page<Contact> findByStatus(String fieldName, Pageable pageable);

                                OR
                                
                                @Query("SELECT c FROM contact WHERE c.status = ?1)
                                Page<Contact> findByStatus(String fieldName, Pageable pageable);

                            --> we can use ? or Named Parameter. 
                            
                            NOTE:
                                Generally, use of ? is not preferred insetead named parameters are preferred because it has more readibility.
            
            @Query with update or delete query:
                        We need to two other annotation @Transcational and @Modifying.

                        @Transcational used to create transcation and when exception occured. It can roll back to previous save point and make changes unchanged.
                        @Modifying used to tell Spring JPA that this custom query will change the state of database.

                        example.,
                            // contactRepository.java
                                @Transactional
                                @Modifying
                                @Query("UPDATE Contact c SET c.status = :status WHERE c.id = :id")
                                int updateStatusById(String status, int id); 

            Query native    :
                        In Native query, we are writing exact SQL query as it would execute inside database. So we need to use exact table name as it is mentioned inside database.

                        example.,
                            // contactRepository.java
                                @Query(value = "SELECT * FROM contact_msg WHERE status = :status", nativeQuery= true)
                                List<Contact> findByStatus(String status, Pageable pageable)

                                OR

                                @Query(value = "SELECT * FROM contact_msg WHERE status = ?1", nativeQuery= true)
                                List<Contact> findByStatus(String status, Pageable pageable)

            Named Query :
                        We have to write JPQL query on top of Model class. Not native query can not be used inside "Named Query".

                        ex.,
                            // contact.java
                                @Entity
                                @NamedQuery(
                                    name = "Contact.findOpenMsgs",   --> method written in contact repository
                                    query = "SELECT c FROM contact WHERE c.status = :status" --> sql query
                                )
                                public class Contact extends BaseEntity{...}

                        NOTE:   
                            We might need to write multiple Named Query for a model class.
                            Hence, use @NamedQueries {} and define all @NamedQuery inside.

                            Also, for update/delete query, we need to mention @Transactional and @Modified.

                            ex.,
                                // contact.java
                                @Entity
                                @NamedQueries{
                                    @NamedQuery(
                                        name = "Contact.findOpenMsgs",   --> method written in contact repository
                                        query = "SELECT c FROM contact WHERE c.status = :status" --> sql query
                                    ),
                                    @NamedQuery(
                                        name = "Contact.updateMsgStatus", --> make sure to add @Transactional and @Modified.
                                        query = "UPDATE contact c SET c.status = :status WHERE c.contactId = :id"
                                    )
                                }
                                public class Contact extends BaseEntity{...}

                                // contactRepository.java
                                    public findOpenMsgs(String status);
                                    
                                    @Transactional
                                    @Modified
                                    public updateMsgStatus(String status, int id);  --> I need to mention @Transactional and @Modified on top of interface method because spring does not know that this method will perform any DML operation. 

            Named Native Query  :
                        Named native query uses SQL query inside.
                        But it is complex and over head as we have to configure inorder to use that.
                        Additionally, It does not support dynamic sorting.
                        Hence I do not recommand to use it.

                        // Spring JPA is used so that we can focus on writing business logic rather than writing SQL query. 
                        // While Named native query, works completly opposite. We have to define sql query and we have to define pre configurations. in order to things to work in spring environment.

AUDITING IN SPRING DATA JPA :
            In business, It is required to audti information about records. Like who inserted the record? And when? Also, who updated record? And when?

            For that, we have created fields in table and class "BaseEntity". Which is accessed by all POJO classes inside webapp.
            // BaseEntity
                @Data
                @MappedSuperclass
                public class BaseEntity {
                    private LocalDateTime createdAt;
                    private String createdBy;
                    private LocalDateTime updatedAt;
                    private String updatedBy;
                }

            But it is hactic and error prone to config to do for all POJO classes. 

            Hence Spring Security and Spring DATA JPA created Auditing:
            
            We have annotation like @CreatedTime, @CreatedBy, @LastModifiedTime and @LastModifiedBy inside spring for Auditing.
            NOTE:
                In general, Created informations are filled initially when records are inserted. And LastModified fields are null as records just got inserted.
                Same with update time, after update, we need to update LastModified information but created informations are untounched.

                Hence, Use @Column(insertable = false) and 
                            @Column(updatable = false).
                
                        Step 1:
                                // Define Auditing fields:
                                    public class BaseEntity {
                                        @CreatedDate
                                        @Column(updatable = false)
                                        private LocalDateTime createdAt;

                                        @CreatedBy
                                        @Column(updatable = false)
                                        private String createdBy;

                                        @LastModifiedDate
                                        @Column(insertable = false)
                                        private LocalDateTime updatedAt;

                                        @LastModifiedBy
                                        @Column(insertable = false)
                                        private String updatedBy;
                                    }
                        Step 2:
                                // And use entity listener to Registers the entity for auditing by using @EntityListeners.
                                    @EntityListeners(AuditingEntityListener.class)
                                    public class BaseEntity { 
                                        ..//code ..
                                    }
                        Step 3:
                                // Implementation to fetch data from Spring Security:
                                // AuditorAware<T> interface expect T as type of data used to define user. User role can be String, Id or an object.
                                    @Component("auditImpleBean")
                                    public class AuditImpl implements AuditorAware<String> {
                                        @Override
                                        public Optional<String> getCurrentAuditor(){
                                            return Optional.ofNullable(SecurityContextHolder.getContext().getAuthentication().getName());
                                        }
                                    }
                        Steep 4:
                                // Enable Auditing from Main application file:
                                @EnableJpaAuditing(auditorAwareRef = "auditImpleBean")
                                public Class EazyschoolApplication {
                                    public static void main(String[] args) {
                                        SpringApplication.run(EazyschoolApplication.class, args);
                                    }
                                }

Relationship in JPA :

            FetchType   :
                        Fetch is used to define how to load child entity when loading parent entiry.

                        FetchType.Eager -   When Parent record is being loaded, all child record can be loaded alongside.
                        FetchType.Lazy  -   When Parent record is being loaded, we do not want child record to be loaded.

                        NOTE:
                            For *ToMany relationship (OneTOMany, ManyToMany), FetchType.Lazy is default type. Since it will hit the performance of system.
                            For *ToOne relationship (OneTOOne, ManyToOne), FetchType.Eager is deafult type. Since it won't hit the performance of system.
                        
            CascadeType :
                        When we make changes to parent records, we want those changes apllied to child records as well.
                        ex.,
                            When we remove a record person from Person table, we want to remove address record from Address table. (Table and Address table have 1:1 relationship)

                        CascadeType.PERSIST     -   When we save parent table data, we also want to save child table data. Often used with save() operation.
                        CascadeType.MERGE       -   When we update parent table data, we also want to update child table data. Often used with update() operation.
                        CascadeType.REFRESH     -   When we fetch parent table data, we also want to fetch child table data. Often used with get() or reload operation.
                        CascadeType.REMOVE      -   When we delete parent table data, we also want to delete child table data. 
                                    NOTE:   REMOVE works with 1:1 relationship else you will see error.
                        CascadeType.DETACH      -   When we detach parenet, we also want to detach all child. Works for cacheing.
                        CascadeType.ALL         -    shortcut to add all CascadeTypes.

                        NOTE:
                            By default, No Operation is cascaded.

            @JoinColumn :
                        used to define reference/ foreign key.
                        where.,
                            name is reference key name inside table.
                            referencedColumnName is field name inside targetEntity.
                            nullable is to tell if field can be null or not. Which is generally used during DDL.

            @OneToOne   :
                        relationship between parent and child is one to one.
                        where.,
                            fetch is used to define how you want to handle child entity.
                            cascade is used to define what actions need to performed on child entity.
                            targetEntity is used to define Child class/model.

                        ex.,
                            @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.PERSIST, targetEntity = Address.class)
                            @JoinColumn(name = "address_id", referencedColumnName = "addressId", nullable = true)
                            private Address address;

AuthenticationProvider  :
            Used for Authentication process. Where we verify credentials added by user.

            Earlier we were using InMemoryUserDetailsManager to save user id-password inside server memory but we can't do this for all users.
            Hence, we need database. 
            In order to verify user id-password typed in login page; we need AuthenticationProvider implemented class to define authentication process.

            NOTE:
                We need to implement 2 methods from interface.
                authenticate()  -
                            Provides custom logic to verify the credentials. If creds are valid, then token is generated in this format: (userName, PWD, role).
                            All the logic (fetch user from db -> check password -> setting password) are implemented here.
                supports()      -
                            System can have multiple AuthenticationProvider like for sernamePasswordAuthenticationToken or for JwtAuthenticationToken.
                            Hence support checks if this AuthenticationProvider needs to be used for handle request.
                        
            Syntex.,
                // class who implements AuthenticationProvider
                    class EazySchoolUsernamePwdProvider implements AuthenticationProvider{
                        @Override
                        public Authentication authenticate (Authentication authentication){
                            // Custom logic to check user password.
                        }

                        @Override 
                        public boolean supports(Authentication authentication){
                            // used to tell system if this method of verification need to use or other.
                            return authentication.equals(UsernamePasswordAuthenticationToken.class);
                        }
                    }

            example.,
                @Component
                public class EazySchoolUsernamePwdProvider implements AuthenticationProvider{

                    @Autowired
                    private PersonRepository personRepository;

                    @Override
                    public Authentication authenticate(Authentication authentication){
                        String email = authentication.getName();
                        String pwd = authentication.getCredentials().toString();

                        Person person = personRepository.readByEmail(email);

                        if(person != null && person.getPersonId() > 0 && pwd.equals(person.getPwd())){
                            //authetication token generation: (username, password, role) token
                            // NOTE: PWD CAN BE NULL AS SPRING TRIES TO REMOVE ALL PASSOWRD RELATED INFO FOR SECURITY PURPOSE.
                            return new UsernamePasswordAuthenticationToken(
                                    person.getName(), pwd, getGrantedAuthorities(person.getRoles()));
                        }
                        else{
                            // return exception which represents authentication/login got failed.
                            throw new BadCredentialsException("Invalid Credentials");
                        }
                    }

                    private List<GrantedAuthority> getGrantedAuthorities(Roles roles) {
                        List<GrantedAuthority> grantedAuthorities = new ArrayList<>();
                        grantedAuthorities.add(new SimpleGrantedAuthority("ROLE_" + roles.getRoleName()));
                        return grantedAuthorities;
                    }

                    @Override
                    public boolean supports(Class<?> authentication){
                        return authentication.equals(UsernamePasswordAuthenticationToken.class);
                    }
                }

Encrypt V/S Encryption V/S Hashing  :
            Encrypt -
                         used to convert one data form to another. Which has no security and used to transfer data from one place to another.
            Encryption  -
                        used cryptography concept for security. 
                        A key is used to convert simple text into encrypted text. 
                        And same key can be used to convert encrypted text back to simple text.
            Hashing -
                        Provides more security compared to Encryption. 
                        Where a hashkey used to create HashValue.
                        ex.,
                            Initially, Hashing is performed on Password before saving it to database. 
                            Now, when user enter password. To valid new input password; same hashing is used and if new hashvalue matches with database hashvalue, Password is valid.
                        Hashing is not reversible. Once data is changed into HashValue. It can't be convert back into original data.

Hashing :
            In-built method BCryptPasswordEncoder() can be used to apply hashing.
            encode()    -
                        Take String as parameter and return hashValue of String.
            equals(para1, para2)    -
                        Returns true if both hashValues are same.
                        NOTE:   para1 is original text enter by user on which hashing is applied. And compared with para2. If matches it return true else false.

            ex.,
                // productConfig
                    @Bean
                    public PasswordEncoder passwordEncoder(){
                        return new BCryptPasswordEncoder();
                    }

                // personService.java file - save hashed value of password inside DataBase.
                    @Autowire
                    private PasswordEncoder passwordEncoder;

                    public boolean createNewPerson(Person person){
                        .. code..
                        // set hashValue during registration:
                        person.setPwd(passwordEncoder.encode(person.getPwd()));
                        person = personRepository.save(person);
                        ..code..
                    }

                // AutheticatorProvider - Check hashValue with user's creds during login
                    @Autowire
                    private PasswordEncoder passwordEncoder;

                    @Override
                    public Authentication authenticate(Authentication authentication){
                        String pwd = authentication.getCredentials().toString();
                        boolean isMatch = passwordEncoder.matches(pwd, person.getPwd()))
                        ..code..
                    }

                NOTE:
                    In spring, Spring Security and JPA both perform validation.
                    In result, matchfield validation is performed twice by spring security and JPA which is unneccessary and error prone.

                    Error prone:
                        1st valiation is performed by spring seurity on login page.
                            Where pwd is matched with confirmPwd. If matches it returns true.
                            And save() operation is performed. Where password is hashed by BCrypt method. and hashValue is stored in DB.
                        2md validation is performed by JPA after save() operation.
                            Now pwd is HashValue and confirmPwd is original input string.
                            In this case, match is always false. 
                        Hence it is neccessary to stop 2nd validation from JPA.

                    Disable JPA Field Validation:
                        // Applciation.properties file
                            spring.jpa.properties.javax.persistence.validation.mode = none

ORM (Object Related Mapping)    :
            NOTE:
                Use of @Data will cause error during mapping because it changes default toString() implementation. 
                So use @Getter and @Setter instead from lambok library.

    OneToMany - ManyToOne   :
                OneToMany relationship between `class` to `people`.
                NOTE:
                    A class can have multiple people. Hence class is Parent. While people is child.

                peoples.java
                    @Entity
                    public class Person extends BaseEntity{
                        @ManyToOne(
                            fetch = FetchType.Lazy,
                            optional = true
                        )
                        @JoinColumn(
                            name = "class_id",
                            referencedColumnName = "classId",
                            nullable = true
                        )
                        private EazyClass eazyClass;
                    }

                class.java
                    @Entity
                    @Table(name = "class")
                    public class EazyClass extends BaseEntity{
                        @OneToMany(
                            MappedBy = "eazyClass",
                            fetch = FetchType.Lazy,
                            cascade = CascadeType.PERSIST,
                            targetEntity = Person.class
                        )
                        private Set<Person> persons;
                    }

    ManyToMany  :
            // Person.java
                @Entity
                public class Person extends BaseEntity{
                    @ManyToMany(
                        fetch= FetchType.Lazy,
                        cascade = CascadeType.PERSIST
                    )
                    @JoinTable(name = "person_courses,
                        joinColumn = {@JoinColumn(name= "", referencedColumnName="")},
                        inverseJoinColumn = { @JoinColumn(name= "", referencedColumnName= "") }
                    )
                    private set<Course> courses = new HashSet<>();
                }

            // Course.java
                @Entity
                public class Course extends BaseEntity{
                    @ManytoMany(
                        fetch = FetchType.Lazy,
                        cascade = CascadeType.PERSIST
                    )
                    private Set<Person> persons = new HashSet<>();
                }

Sorting with JPA    :
            In springBoot application, we do not have to write SQL queries where JPA will take care of it.
            To perform sorting, we can use JPA sorting.
                ->  Static Sorting 
                ->  Dynamic Sorting

            Static Sorting  :
                        Sorting are perfomed during the execution of SQL query. 
                        And can not be changed during runtime.
                        ex.,
                            List<Person> findByIdOrderByNameDesc();
                    
            Dynamic sorting :
                        Sorting can be changed during runtime. 
                        ex.,
                            Sort sort = Sort.by("name").descending().and(Sort.by("age"));

Pagination with JPA :
            To show Big data in various pages, Pagination is used.
            We can apply Paging and Dynamic sorting with it.
            ex.,
                // personService.java
                    Page<person> findMsgWithOpenstatus(int pageNum, String order){
                        // Define how sort and pageable you want to perform:
                        //Pagable pagable = PageRequest.of(int page, int size, Sort sort);
                        Pageable pagable = PageRequest.of(pageNum -1, 5, ( (order.equals("asc"))? Sort.by(name).descending: Sort.by(name).ascending));

                        // use pagable to retrieve data from database. Data retrieved based on 
                        Page<Person> findAll(pageable);  --> find all person based on Name passed inside parameter.
                    }
                    
                // person.java
                    // use Page<T> methods:
                    Page<Person> pagePersonList = personService.findMsgWithOpenstatus(1, "asc");

REST services terms :
            SOAP    -   Simple Object Access Protocol
            REST    -   Representational State Transfer 
            JSON    -   JavaScript Object Notation

            REST    :
                        REST uses JSON format to exchange data.

REST Services in Spring MVC (Internal Flow):
            Step 1: End point/Application sends Http request to the server container. (Server Container can be anything like TomCat server.)
            Step 2: Server Container will accept the request and handover request to server Dispatcher.
            Step 3: Server Dispatcher will check with "Handler Mapping" which will return controller and method name.
            Step 4: Server Dispatcher will execute Controller Method.
                        Controller method will return output. It will not send any view details as REST service only give data. View will be taken care by other services.
                        ex.,
                            @GetMapping("/getMessages")
                            @ResponseBody
                            public List<Contact> getMsgsWithOpenStatus(String status){  ... }
            Step 5: Server dispatcher will send this data to Server Container.
            Step 6: Server Container will send data to End point/Application.

REST Service:
            In spring, Every request intercept by spring security so we need to add requestMatcher() for APIs. 
            NOTE: We might not need to handle CSRF as other service will take care of CSRF.

            @ResponseBody   -   
                        Used to define method as REST api. 
                        Where JSON value is converted to POJO value.
            @RequestBody    -   
                        Used to define incoming parameter will be an JSON. 
                        Where POJO value converted into JSON value.
            @RESTController -
                        Combination of @Controller and @ResponseBody.
            @ResponseEntity -
                        returns a json object which have many information in it. like header value, httpStatus value and POJO class which is converted back to JSON format.
            @RequestEntity  -
                        Accept incoming Json object which contains information like header, body Json etc. 
                        After accepting entity, we can perform backend logic.

            NOTE:
                If you authentication is required to use API, use authentication open inside POSTMAN and enter credentials.

            REST Service using Query parameter:
                        Query value is expected during API call.
                        ex.,
                            @GetMapping("/getMessagesByStatus")
                            @ResponseBody
                            public List<Contact> getMessagesByStatus(@RequestParam(name = "status") String status){
                                return contactRepository.findByStatus(status);
                            }

            REST Service using RequestBody:
                        Json object is expected during API call.
                        NOTE:
                            you need to pass JSON value from postman's BODY
                                {
                                    "status": "Close"
                                }
                            Also, Return type form the method is JSON so change "Accept" to "Application/json" in PostMan header.

                        ex.,
                            @GetMapping("/getAllMsgsByStatus")
                            @ResponseBody
                            public List<Contact> getAllMsgsByStatus(@RequestBody Contact contact){
                                if(contact != null && contact.getStatus()!= null)
                                    return contactRepository.findByStatus(contact.getStatus());
                                else
                                    return List.of();
                            }  

            REST Service using RESTController   :
                            We are using @Controller and @ResponseBody in above implementation.
                            Alternatively, we can use @RESTController. which is combination of both.

                            ex.,
                                @RESTController
                                public class ContactRestController{
                                    @GetMapping("/getAllMsgsByStatus")
                                    public List<Contact> getAllMsgsByStatus(@RequestBody Contact contact){
                                        if(contact != null && contact.getStatus()!= null)
                                            return contactRepository.findByStatus(contact.getStatus());
                                        else
                                            return List.of();
                                    } 
                                }

            REST Services to save data  :
                            We need to send response with error code and messages after the succesful save operation.
                            So create a model "response" with 2 fields error-code and error-msg.

                            we can accept header from postman. to catch it, we can use @RequestHeader.
                            The json object sent from postman need to be validated by spring validation. We can do it by @Valid annotation.

                            For return value, you can send a POJO object or you can send ResponseEntity object.
                            Pojo and ResponseEntity object will be created back to JSON value.
                            But ResponseEntity will have extra information about httpResponse. Information like., status code, header value etc.
                            
                            // Response.java
                                @Data
                                @NoArgsConstructor
                                @AllArgsConstructor
                                public class Response {
                                    private String statusCode;
                                    private String statusMsg;
                                }
                            
                            // RESTController
                                @PostMapping("/saveMsg")
                                public ResponseEntity<Response> saveMsg(@Valid @RequestBody Contact contact, @RequestHeader("form") String form){
                                    log.info("retrieved value is: " + form);

                                    contactRepository.save(contact);

                                    Response response = new Response();
                                    response.setStatusMsg("saved succesful");
                                    response.setStatusCode("200");

                                    return ResponseEntity
                                            .status(HttpStatus.CREATED)  --> which is converted back to 201 status at postman.
                                            .header("isMsgSaved", "true")
                                            .body(response);
                                }

            REST Services to delete data    :
                        Same way but with the use of ResponseEntity and RequestEntity.
                        ex.,
                            @DeleteMapping("/deleteMsg")
                            public ResponseEntity<Response> deleteMsg(RequestEntity<Contact> requestEntity){
                                HttpHeaders headers =  requestEntity.getHeaders();
                                log.info(headers.toString());

                                Contact contact = requestEntity.getBody();
                                if(contact!= null && contact.getContactId()> -1) {
                                    contactRepository.deleteById(contact.getContactId());
                                }

                                Response response= new Response("200", "deleted succesfully");
                                return ResponseEntity
                                        .status(HttpStatus.OK)
                                        .header("isDeleted", "Yes it is deleted")
                                        .body(response);
                            }

Global Exception Controller for REST Services   :
            NOTE:
                We need to give this GlobalExceptionRESTController order 1. 
                Because Spring randomly uses both GlobalExceptionController and GlobalExceptionRESTController to handle exception.
            
            Here, 2 types of error can be handle.
            -> Server side error/exception
            -> invalid @RequestBody sent from postman

            ex.,
                @Slf4j
                @RestControllerAdvice(annotations = RestController.class)
                @Order(1)
                public class GlobalExceptionRESTController extends ResponseEntityExceptionHandler {

                    //@Override
                -----> to handle invalid requestBody:
                    protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException exception,
                                                                                HttpHeaders headers,
                                                                                HttpStatus status,
                                                                                WebRequest request){
                        Response response = new Response(status.toString(), exception.getBindingResult().toString());
                        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
                    }

                -----> to handle server exception:
                    @ExceptionHandler({Exception.class})
                    public ResponseEntity<Response> responseException(Exception exception){
                        Response response = new Response("500", "Internal server error");
                        return ResponseEntity
                                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(response);
                    }
                }

XML based Rest Services :
            By default, JSON format is being used inside SpringBoot.

            But to use XML based Rest Services, you need to perform 2 actions:

            Step 1:
                // Add dependency
                <dependency>
                    <groupId>com.fasterxml.jackson.dataformat</groupId>
                    <artifactId>jackson-dataformat-xml</artifactId>
                </dependency>

            Step 2:
                // Use produces parameter to either class level RequestMapping or method level RequestMapping/ PostMapping/ GetMapping.

                ex.,
                    // Method level -> XML will work for that method only.
                        ex.,
                            @GetMapping(value = "/getMessagesByStatus", produces = MediaType.APPLICATION_XML_VALUE)
                            @ResponseBody
                            public List<Contact> getMessagesByStatus(@RequestParam(name = "status") String status){
                                return contactRepository.findByStatus(status);
                            }

                    // Class Level  --> XML will work for all methods.
                        ex.,
                            @RestController
                            @RequestMapping(value = "/api/contact", produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
                            @CrossOrigin(origins = "*")
                            public class contactRestController {    ... }

            Step 3:
                // PostMan: request for XML based output.

                Go to the header and add {accept = application/xml}.

CORS (Cross-Origin Resource Sharing)    :
            CORS is default protection setting by browser where 2 different Origins can't communicate.
            browser will block communicate between frontend origin and backend origin communication by default.

            To enable it, use @CrossOrigin(origins = "*") or specify origin value by  @CrossOrigin(origins = "http://localhost:/8080") on top of your REST Controller.

            ex.,
                // contactRestController.java
                @RestController
                @CrossOrigin(origins = "*")
                public class contactRestController {    ... }

Avoid sharing confidencial information by REST services :
            We are saving audit related informations inside table. Like created, createdBy, modifiedBy, LastModified etc.

            To ignore to sharing confidencial information by @JsonIgnore and @JsonIgnoreProperties
            ex.,
                // On top of field name inside Model class:
                    @JsonIgnore
                    private LocalDateTime createdAt;

                OR

                // On top of Model class:
                    @JsonIgnoreProperties(value = {"createdAt, createdBy, LastModifiedBy, LastModifiedByAt})
                    class Contact{...}

Consume created REST services Another application   :
            OpenFeign   -
                        A tool offered by Spring Cloud project.
            RestTemplate    -
                        A tool to call REST endpoints.
                        It is blocking Async and Sync invocations. Hence, new application prefer WebClient.
            WebClient   -
                        A tool to call REST endpoints.
                        It is part of the Spring Web Reactive module.
                        And It supports Async and sync invocations. (Non-blocking tool)

            CREATE A PROJECT SPRING-CLOUD PROJECT   :
                    Add properties:
                                <spring-cloud.version>2023.0.3</spring-cloud.version>
                    Add dependencies:
                                <dependencies>
                                    <dependency>
                                        <groupId>org.springframework.boot</groupId>
                                        <artifactId>spring-boot-starter-web</artifactId>
                                    </dependency>
                                    <dependency>
                                        <groupId>org.springframework.boot</groupId>
                                        <artifactId>spring-boot-devtools</artifactId>
                                    </dependency>
                                    <dependency>
                                        <groupId>org.springframework.cloud</groupId>
                                        <artifactId>spring-cloud-starter-openfeign</artifactId>
                                    </dependency>
                                    <dependency>
                                        <groupId>org.springframework.cloud</groupId>
                                        <artifactId>spring-cloud-starter-loadbalancer</artifactId>
                                    </dependency>
                                    <dependency>
                                        <groupId>org.projectlombok</groupId>
                                        <artifactId>lombok</artifactId>
                                        <version>1.18.30</version>
                                    </dependency>
                                    <dependency>
                                        <groupId>org.springframework.boot</groupId>
                                        <artifactId>spring-boot-starter-webflux</artifactId>
                                    </dependency>
                                    <dependency>
                                        <groupId>org.springframework.boot</groupId>
                                        <artifactId>spring-boot-starter-test</artifactId>
                                        <scope>test</scope>
                                    </dependency>
                                </dependencies>
                    Add dependencyManagement:
                                <dependencyManagement>
                                    <dependencies>
                                        <dependency>
                                            <groupId>org.springframework.cloud</groupId>
                                            <artifactId>spring-cloud-dependencies</artifactId>
                                            <version>${spring-cloud.version}</version>
                                            <type>pom</type>
                                            <scope>import</scope>
                                        </dependency>
                                    </dependencies>
                                </dependencyManagement>

            Consume REST Services Using FeignClient  :
                        Step 1:
                            Add credentials to "BasicAuthRequestInterceptor" so that API can be accessed. 
                            ex.,
                                On API side, if spring security is configured and API can only be accessed by Admin. 
                                We need to login as Admin to access API to another application.

                            Enable FeignClient in main method. Otherwise bean not found exception will be occured.
                        Step 2:
                            Abstract method to consume REST services. like., contactProxy.java
                        Step 3:
                            Use abstract method to fetch data and use it inside application. like., contactController

                        EXAMPLE:
                            Step 1: Add AuthIntercept inside config file to provide credentials during API call.
                                // ProductConfig.java
                                @Bean
                                public BasicAuthRequestInterceptor basicAuthRequestInterceptor(){
                                    return new BasicAuthRequestInterceptor("test@admin1.com", "test@admin1");
                                }

                            Step 2: Enable FeignClient in main Application file
                                // KpApplication file
                                @SpringBootApplication
                                @EnableFeignClients(basePackages = "com.kp.proxy")
                                public class KpApplication {    ...}

                            Step 3: Implement Abstract method to get API data:
                                // ContactProxy
                                @FeignClient(
                                        name = "contact",
                                        url = "http://localhost:8080/api/contact",
                                        configuration = ProductConfig.class
                                )
                                public interface ContactProxy {
                                    @RequestMapping(method = {RequestMethod.GET}, value = "/getMessagesByStatus")
                                    @Headers(value = "Content-Type:application/json")
                                    public List<Contact> getMessagesByStatus(@RequestParam("status") String status);
                                }
                            
                            Step 4: Use the Abstract method inside application:
                                (To test with postman, lets create REST method inside SpringCloud application)
                                // ContactController
                                @Autowired
                                ContactProxy contactProxy;

                                @GetMapping("getMessagesByStatus")
                                public List<Contact> getMessagesByStatus(@RequestParam("status") String status){
                                    return contactProxy.getMessagesByStatus(status);
                                }

                            Step 5: Test in PostMan application
                                // Call controller method:
                                http://localhost:8081/getMessagesByStatus?status=Open

            Consume REST Services Using RestTemplate    :
                // It is stright POJO class to use RestTemplate. And Do not use this as it is deprecated.

                    @PostMapping("/saveMsg")
                    public ResponseEntity<Response> saveMsg(@RequestBody Contact contact){
                        String uri = "http://localhost:8080/api/contact/saveMsg";
                        HttpHeaders headers = new HttpHeaders();
                        headers.add("invocationFrom","RestTemplate");
                        HttpEntity<Contact> httpEntity = new HttpEntity<>(contact, headers);
                        ResponseEntity<Response> responseEntity = restTemplate.exchange(uri, HttpMethod.POST,
                                httpEntity,Response.class);
                        return responseEntity;
                    }

            Consume REST Services Using WebClient   :
                Step 1. Give Credentials to webClient using ExchangeFilterFunctions
                    @Bean
                    public WebClient webClient(){
                        return WebClient.builder()
                                .filter(
                                        ExchangeFilterFunctions.basicAuthentication("test@admin1.com", "test@admin1")
                                )
                                .build();
                    }
                
                Step 2. Consume REST Service    :
                    @PostMapping("/saveMessage")
                    public Mono<Response> saveMessage(@RequestBody Contact contact){        --> reactive model MONO is used to perform WebClient call. BECAUSE OF Unblocking behaviour (Sync and Async)
                        String uri = "http://localhost:8080/api/contact/saveMsg";   --> URI of hosted REST Services

                        return webClient.post().uri(uri)        --> use webclient's post method and send URI 
                                .header("form", "WebClient")    --> add header if needed.
                                .body(Mono.just(contact), Contact.class)    --> send body() but 2 parameters are required. one to cover contact RequestBody in MONO Reactive model. and class model in 2nd parameter.
                                .retrieve()                     --> call hosted REST Services
                                .bodyToMono(Response.class);       --> cover return data in MONO Reactive model.
                    }

Http Method type:
            SAFE type           :   Which does not the change state of table. ex., GET, HEAD, OPTIONS
            UNSAFE type         :   Which changes the state of table. ex., POST, PUT, DELETE
            IDEMPOTENT type     :   Making same request gives same result. ex., GET, HEAD, PUT, DELETE
            NON-IDEMPOTENT type :   Making same request gives diff result. ex., POST, PATCH

            Method	Safe?	Idempotent?	Description
            GET	     Yes	 Yes	Retrieve data without modifying it
            HEAD	 Yes	 Yes	Retrieve headers without modifying data
            OPTIONS	 Yes	 Yes	Check available methods without modifying data
            PUT	     No	 Yes	Update/replace a resource (same result on multiple calls)
            DELETE	 No	 Yes	Delete a resource (same result if repeated)
            POST	 No	 No	Create a resource (different result if repeated)
            PATCH	 No	 No	Partially update a resource (not guaranteed to be idempotent)

Spring DATA Rest    :
            This dependency will create all REST services based on model.
            "/profile" link will show all apis for a model.
                        "id" will REST method name.
                        "type" are Http Request type. (SAFE, UNSAFE, IDEMPOTENT)    

            NOTE:
                All REST Services will be visited at localhost:/profile. Hence add requestMatcher in spring security.
        
            STEPS:
                Step 1. Add dependency of Spring DATA Rest.
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-data-rest</artifactId>
                    </dependency>
                
                Step 2. Add spring security for "/profile".
                    // SecurityConfig.file
                    .requestMatchers("/profile/**").authenticated()

                NOTE:   Profile controller will be created by Spring DATA Rest. Hence, make sure to create unique bean name for existing Profile controller.

                Step 3. OPEN link "http://localhost:8080/profile" to view all RestAPIs.

Explore ALL Services provided by an application using Spring DATA Rest  :
            "localhost:/profile" will give all links to 'MODEL'. Which exist inside the application.

            "localhost:/MODEL_NAME/search" will expose all APIs/ Methods exist for the current 'MODEL'. 
            NOTE:
                Spring security will give Unauthorized error so add these links inside configuration.
                ex.,
                    .requestMatchers("/contacts/**").permitAll()

            EXPOSE ALL Contacts APIS and methods:
                http://localhost:8080/contacts/search

                in JSON format, it will show all APIs/ Methods.

            USE Method from '/search':
                JSON file:
                    "findByStatusPagination" : 
                    {
                        "href" : "http://localhost:8080/contacts/search/findByStatusPagination{?status,page,size,sort*}",
                        "templated" : true
                    }
                Use href:
                    replace {} variable with values.
                        status = OPEN
                        page = 1
                        size = 4
                        sort = name, asc

                    NEW LINK WILL BE:
                        http://localhost:8080/contacts/search/findByStatusPagination?status=Open&page=0&size=10&sort=name,asc

            ***NOTE***  
                @JsonIgnore
                    By using this apporach we can see, what data is being sent by Application if REST call is made.

                    These API calls result will show all fields in JSON format.
                    Here you can validate which field value should not be shared during API call.

                    Use @JsonIgnore to exclude that field from API call.

HALExplorer :
            HALExplorer UI can be used to explore all APIs/ Methods.
            It provides nice UI and buttons to test APIs/ Methods.

            NOTE:
                HALExplorer opens on default link. Which is "localhost:8080/".

                Configure link to open HALExplorer and Spring DATA Rest in common link:
                    add configuration line:
                        spring.data.rest.basePath= /data-api

                Spring DATA Rest will open at "localhost/data-api/profile".

            NOTE:
                @RepositoryRestResource(path = "course")
                class course{   ... }

                This will rename all HALExplorer and Spring DATA Rest API name to 'localhost:/data-api/course/search' -> to view all APIs inside "course" model.

            NOTE:
                @RepositoryRestResource(exported = false)
                class course{   ... }

                This will disable exporting of APIs/ Methods of the "Course" model.

            ADD Security configuration to access this link.

Exceptions  :
                NoSuchBeanDefinitionException       :
                            When you try to get bean using context.getBean("Vehicle.class") and no vehicle bean is found from IOC container. It will return this exception.

                NoUniqueBeanDefinitionException     :
                            When you try to inject a bean by a type but project config file has multiple beans with same type, this Exception is thrown.
                            ex.,
                                // projectConfig.java
                                    @bean
                                    String firstName(){
                                        return "John";
                                    }

                                    @bean 
                                    String lastName(){
                                        return "Doe";
                                    }

                                // main.java
                                    var context = new AnnotationConfigApplicationContext(projectConfig.class);
                                    var name = context.getBean(String.class);  
                                    // Exception will be thrown as there are two beans with same type.   

                                    //use this instead:
                                    var name = context.getBean("firstName", String.class);  // John
                                    var name2 = context.getBean("lastName", String.class);  // Doe

                                    // Or use @Primary Annotation in projectConfig.java class.
                                
                            NOTE:   
                                if we have x2 @Primary annotation for same data types we will get Exception "NoUniqueBeanDefinitionException" with proper message saying "more than 1 @Primary annotation".

                UnsatisfiedDependencyException      :
                            When Circular dependency is created, this exception is thrown.
                            When A bean trying initiate another bean and other bean is try to initiate first bean. This exception is thrown. 
                            There is no solution for this. So we have to avoid this situation.

                            It can be easily discovered as we can not even start out server.

                            ex.,
                            // Circular dependency:
                                class person{
                                    @Autowired
                                    private Vehicle veh; // person class is trying to initiate vehicle class.
                                }

                                class Vehicle{
                                    @Autowired
                                    private Person p;   // vehicle class is trying to initiate person class.
                                }
 
Logger Level    ::
        // application.properties file
            debug = true    --> it will execute all log related statement during run-time of an application. Used to debug Spring-starter issues, auto-configuration, or routing-issues.
            trace = true    --> Detailed tracing will be performed during run-time of an application. Used to debug HTTP request flow, security filters, or method execution details.

        (General logging level - QA team)
            Fatal       -   System crash or not working.
            Error       -   Issue on system but functionalities are working properly.
            Warn        -   Unexpected behaviour (System working fine)
            Info        -   Informative event occured.
            Debug       -   Useful while debugging the code.
            Trace       -   For extended debugging sessions.

        (Java Built-in Logger)
            SEVERE      -   Critical Error
            WARNING     -   Unexpected behavior but system works fine.
            INFO        -   general information realated message.
            CONFIG      -   configuration-related message.
            FINE        -   detailed Trance-debugging message.
            FINER       -   even more detailed Debugging message.
            FINEST      -   finest level of debugging message.

        Syntex  :
            logger.log(Level.SEVERE, "This is a message.");
            logger.log(Level.INFO, "Informative message.");
            logger.log(Level.CONFIG, "Configuraion message.);
            ...
