interface   :
            Interface is used to achieve loosely coupling between components.
            Interface is used to achieve Abstraction and multiple inheritance.

            NOTE:
                Variable inside Interface is by default "public static final".

            ABSTRACT METHOD(NORMAL WAY):
                    We must have to use all interface method inside class.
                        interface A{
                            void call();
                        }
                        class B implements A{
                            // Mandatory implementation
                            void call(){
                                System.out.println("call method");
                            }
                        }
            DEFAULT METHODS:
                    It is optional method. 
                    It can be accessible from class object.
                    It can be overridden.
                        interface A{
                            default void call();
                        }
                        class B implements A{
                            // optinal to use call() method from interface.
                            ..
                        }
            STATIC WAY:
                    Static method can be accessible by interface only. We can't access static method from object of a class.
                        example.
                            interface A{
                                static void call(){
                                    System.out.println("interface instance");
                                }
                            }
                            class B implements A{
                                // Can not override static method of interface.
                                ..
                            }
                            class Test {
                                public static void main(String[] args) {
                                    A.info(); // Access via interface
                                    // obj.info(); // ERROR: Cannot access via object
                                }
                            }

Spring takes components from Jakartaka if concept is helpful to developers. / Spring borrows the annotations from Java EE.

How to create a project in IntelliJ:
            Open new Project -> Name project -> Select Location to be stored -> Build system: Maven -> Java JDK 17 -> Create it.

            To use Spring Framework in our project, we need to include it "pom.xml" file. Copy "GAV" from mvnRepository website.
            
            Note:
                To identify a project uniquely "GAV" is used. 
                {"GroupID", "ArtifactID" and "Version" are combined to create a key.}
                    GroupID     -   It represents that which organization's project is this. 
                                    If it is Google.com then Group ID will be com.Google
                    ArtifactID  -   It's project name which you decide while creating a project.
                    Version     -   Release version of Project. ex., V3.0.1 

Loosely Coupling V/S Tightly Coupling:
            When A classes are highly depedent on each other, making changes to them is difficult and requires more testing and less resuable.
            ex.,
                main class directly initiats JSON class and uses CreateDoc method.

            When Classes are independent of each other, making changes are more flexible and require less testing and more resuable.
            ex.,
                main class uses interface which allow dev to use any class.

            NOTE:
                    To create Loosely coupling:
                        - implment Interface/ Abstract classes
                        - Dependency Injection { In constructor, Setter or Interface }
                        - Factory pattern (implement Interface so subClasses can be changed.)
                        (many more)

            -> If dev team are using AWS as cloud service and later they found AWS is charging much higher than it used to and client can not afford it. So dev team have to use another cloud service like GCS. 
                So, if devs initiate classes directly and want to change make change then it will be so difficult as it is tightly coupling case.
                But if dev used interfaces and passing classes as parameters. it will be easy to make changes as we need to create new method in interface. It is loosely coupling example.

            EXAMPLE:
                    Tightly Coupling:
                            Class PDF{
                                String print(){
                                    return "PDF has been created";
                                }
                            }

                            main{
                                PDF pdf= new PDF();
                                System.out.println(pdf.print());
                            }

                    Loosely Coupling:
                            interface generator(){
                                public void output();
                            }

                            class PDF implements generator{
                                String print(){
                                    return "PDF has been created";
                                }
                            }

                            class WORD implements generator{
                                Stirng print(){
                                    return "WORD has been created";
                                }
                            }

                            Class docs{
                                private generator();

                                public docGenerate(generator Gen){
                                    this.generator= Gen;
                                }

                                void print(){
                                    System.out.println(Gen.print());
                                }
                            } 

                            main{
                                generator pdf= new generator();
                                docs D1= new docs(pdf);
                                // return PDF
                                D1.print();

                                generator word= new generator();
                                docs D2= new docs(word);
                                // return WORD
                                D2.print();
                            }

           
            Loosely Coupling V/S Tightly Coupling:
                Definition :
                            ->  Classes or modules are highly dependent on each other.
                            ->  Classes or modules are independent and rely on abstractions. 
                | Flexibility         | 
                Low. Changes in one class require changes in others. 
                High. Components can be easily swapped or modified. |
                | Maintainability     | 
                Difficult. Harder to update, fix bugs, or add features. 
                Easier. Changes are isolated, reducing the impact on the system. |
                | Testing             | 
                Challenging. Difficult to isolate and mock components.
                Easier. Components can be easily tested in isolation. |
                | Reusability         | 
                Low. Reusing a class in a different context is difficult.
                High. Components are more modular and can be reused easily. |
                | Performance         | 
                Often better, as there's no overhead from abstraction. 
                Potential overhead due to abstraction layers or DI frameworks. |
                | Simplicity          | 
                Simpler to implement for small-scale projects.
                More complex, requires careful design and use of patterns. |
                | Dependency Management | 
                Direct. Classes explicitly instantiate and manage dependencies. | 
                Indirect. Dependencies are managed through interfaces or DI. |
                | Design Effort       | 
                Requires less upfront design. | 
                Requires more upfront design and architectural planning. As we need to create interfaces and classes as well.
                | Code Change Impact  | 
                High. A change in one module can affect many others. | 
                Low. Changes in one module have minimal impact on others. Just need to change parameter in main method.
                | Examples            | 
                Direct instantiation of objects within a class. | 
                Use of interfaces, abstract classes, or dependency injection. |
                | Risk of Over-Engineering | 
                Low. Fewer abstractions lead to simpler code. | 
                Higher. Abstractions can sometimes lead to unnecessary complexity. Unneccessary implementation of interface when it can be done easily by classes only.

How execution is performed: 
        Your main logic is separated from the object creation/configuration logic. 
        Spring handles the instantiation of beans, making your code more modular and maintainable.

        Conversion in main.java file:
            IoC container (context) --> Extract Bean component --> perform action
            ex.,
                var context = new AnnotationConfigApplicationContext(projectConfig.java);
                var beanComponent = context.getBean("classname", String);
                System.out.println("Access_Spring" + beanComponent.getName());

        NOTE:
            All bean components (singleton beans) are created from top to down when ApplicationContext is initialized.

Concept that I understand:
            -> 
                If you want to create Beans manually, we need to configure configuration file.
                This will give more freedom to choose which bean compoent we want to use.
                Where @Autowire is allowed to use inside Bean component.

Annotations  :
            Custom Bean name:
                        // Bean naming using "name" keyword:
                            @Bean(name = "Vehicle1")
                            Vehicle v1(){
                                return new createVehicle("BMW");
                            }

                        // Bean naming using "value" keyword:
                            @Bean(value = "Vehicle2")
                            Vehicle v2(){
                                return new createVehicle("Audi");
                            }

                        // Bean naming using Shortcut method:
                            @Bean("Vehicle3")
                            Vehicle v3(){
                                return new createVehicle("GWagon");
                            }

                Note: 
                        If bean components have same name, it will overwrite names and you will be able to access only one. 
                        The one which you can access is soly based on how spring processes.
                        ex.,
                            // projectConfig.java
                                @Bean(name = "v24")
                                Vehicle vehicle(){
                                    return new Vehicle("krunal", "BMW");
                                }

                                @Bean(name = "v24")
                                Vehicle vehicle2024(){
                                    return new Vehicle("2nd Class", "panda");
                                }

                            // main.java
                                System.out.println(context.getBean("v24", Vehicle.class));
                                --> It could be first or last bean compoent of same custom bean name.

            @Primary:
                        It decides default bean when user is trying to fetch Vehicle type bean.
                        ex., context.getBean(Vehicle.class);

                        @Primary annotation will make that Bean default bean.
                        ex.,
                            // projectConfig.java
                                @Bean
                                Vehicle vehicle(){
                                    return new Vehicle("krunal", "BMW");
                                }

                                @Primary
                                @Bean
                                Vehicle vehicle2024(){
                                    return new Vehicle("2nd Class", "audi");
                                }

                            // main.java
                                System.out.println(context.getBean(Vehicle.class));
                                --> Primary bean will be returned here.

                        Note: 
                            We can assign @Primary annotation to multiple Beans which result in NoUniqueBeanDefinitionException.

                            ex.,
                                // projectConfig.java
                                    @Primary
                                    @Bean
                                    Vehicle vehicle() {
                                        var veh = new Vehicle();
                                        veh.setName("Audi 8");
                                        return veh;
                                    }

                                    @Primary
                                    @Bean
                                    Vehicle vehicle2() {
                                        var veh = new Vehicle();
                                        veh.setName("bmw");
                                        return veh;
                                    }

                                // main.java
                                Vehicle v = context.getBean("audi", "Vehicle.class");

                                --> result in exception

                        NOTE:

                            ex.,
                                // projectConfig.java
                                    @Primary
                                    @Bean("audi")
                                    Vehicle vehicle() {
                                        var veh = new Vehicle();
                                        veh.setName("Audi 8");
                                        return veh;
                                    }

                                    @Primary
                                    @Bean("bmw")
                                    Vehicle vehicle2() {
                                        var veh = new Vehicle();
                                        veh.setName("bmw");
                                        return veh;
                                    }

                                // main.java
                                Vehicle v = context.getBean("audi", "Vehicle.class");

                                --> getContext() will look for only Vehicle bean whose name is "audi". As a result, it won't thorw exception because only one bean found with "audi" name.

                                if we found multiple bean with "audi" name, it will resturn @primary annoted Vehicle bean.

                                NOTE:
                                    if you have beans with "audi" names and mistakenly assign @Primary to multiple beans. it will throw NoUniqueBeanDefinitionException.

            @Component:
                        in real world to avoid writing @bean for all class; we write @component Annotation on class definition.

                        NOTE:
                            Spring will automatically create a single bean. (as part of Singleton bean scope)
                            To create more beans of same class, we need to use @CompoentScan in config file.

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:
                                }

                            // productConfig file
                                @ComponentScan(com.kpriyadarshi.beans);  --> this will scan all files from "Beans" folders.
                                public class ProjectConfig {
                                    ... empty file - as bean will be created with @CompoentScan ...
                                }

                            result -> when we run method. it will print Null for vehicle name. As we haven't assign value.

            @ComponentScan:
                        Spring has default feature to scan components where @Configuration or @SpringBootApplication is mentioned.
                        But when @Component is used we need to use @ComponentScan so that we know which beans to create.
                        
                        We need to include in a file where beans are created. Generally we mention this inside Config files.

                        ex.,
                            //productConfig.java
                                @ComponentScan(basePackage= "com.example.beans")
                                class productConfig(){
                                    ... methods to create beans ...
                                }

                        ComponentScan has more parameters...
                            @ComponentScan(
                                basePackage = "com.example.beans",
                                includeFilters = ...,
                                excludeFilters = ...
                            )

            @PostConstruct:
                        Executes when bean is created but constructor execute first.
                        NOTE:
                            First class's constructor is initialized. and after that @PostConstruct is executed.
                            -> If B is child class of A then first A's constructor will execute then B's constructor will execute after that A's @PostConstruct and B's @PostConstruct execute.

                        It is used to ensure custom configuration and logic has been implemented before the execution it is used.                       

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:

                                    @PostConstruct
                                    public void init(){
                                        this.name = "Honda";
                                    }
                                }

                            Result -> It will assign "honda" name to Vehicle class. else it will show null value when we try to print name of it.

            @PreDestroy:
                        Executes automatically when bean is being destroyed by spring framework.
                        Used to disconnect database, close file, Release a source etc.

                        NOTE: To use @PreDestroy annotation, we need to close ApplicationContext.

                        ex.,
                            // Vehicle.java
                                @Component
                                public class Vehicle {
                                    private String name;
                                    Getter and Setter method:

                                    @PreDestroy
                                    public void destroy(){
                                        System.out.println("Closing Vehicle bean: " + this.name + "!");
                                    }
                                }

                            // Main.java
                                public static void main(String[] args) {
                                    var context = new AnnotationConfigApplicationContext(ProductConfig.class);
                                    -- use below line to execute @PreDestroy annotation:
                                    context.close();
                                }
                            
                            Result: It will execute @PreDestroy methods.

Hardcorded dependency/ Thight Coupling :: 
                        Vehicle class manually assigned to Person class in the configuration file. 
                        Doing so create Manual and TIGHTLY COUPLING.
                            ex.,
                                // productConfig.java
                                    @Configuration
                                    public class ProjectConfig {

                                        @Bean
                                        public Vehicle vehicle() {
                                            Vehicle veh = new Vehicle();
                                            veh.setName("Audi 8");
                                            return veh;
                                        }

                                        @Bean
                                        public Person person() {
                                            Person person = new Person();
                                            person.setName("John");
                                            person.setVehicle(vehicle()); // Manually setting dependency
                                            return person;
                                        }
                                    }

                        Now We want to add Model field (from CAR class which is subclass of Vehicle) to above code:
                            ex.,
                                // Create Car.java file with one field "modelName". 

                                // ProductConfig.java   
                                    @Primary
                                    @Bean
                                    public Vehicle createVehicle1(){
                                        var car = new Car();
                                        car.setModelName("i3");
                                        car.setName("BMW");
                                        return car;
                                    } 

                        Here, we need to change whole createVehicle1() method. 
                        Just imagine if we have x5 methods then we need to change entire ProductConfig.java file.

Wiring beans/ Loose Coupling   ::
                Remember, with one constructor we do not need to use @Autowired. It is optional and it will consider a dependency between both beans.

                Wiring beans using Method parameters: 
                        { Not a Good way to wire components as when change occures, We have to make changes everywhere. }
                            
                            In productConfig file, we will have person() method. 
                            Where we will use setVehicle() method from Person class and pass existing vehicle method from "productConfig" file.
                            ex., 
                                public Vehicle veh_Method(){
                                    Vehicle v = new Vehicle();
                                    v.setName("1k");
                                    return v;   
                                }

                                public Person person_Method(){
                                    Person p = new Person();
                                    p.setVehicle(veh_Method());  // method name is passed as parameter.
                                    return p;
                                }

                            NOTE:
                                ->  Instead of creating Vehicle bean for veh_method and person_method, Spring as default behaviour creates one Vehicle bean and give them. 
                                    You can use print statement in both constructors to validate above statement.
                                ->  We won't face any ambiguity as we are passing method name inside person method.

                Wiring beans using method calls:
                            Here, we will pass parameter "Vehicle veh_Temp". and everything is wired by spring. 
                            ex.,
                                public Person person_Method(Vehicle veh_Temp){
                                    Person p = new Person();
                                    p.setVehicle(Vehicle veh_Temp);  // instead of passing method name, we are passing object.
                                    return p;
                                } 

                            NOTE: As auto wiring is done by spring, we might face ambiguity if we have 2 beans with same data type.
                                    To avoid, we can use @Primary annotation.
                                    or @Qualifier("name_of_bean") annotation.                                    
                                    or It will match with the name given on parameter inside class and name given on configProduct file.

                                    ex.,
                                        class person{
                                            
                                        }

                Wiring beans using @Wiring annotation   : 
                                @Wiring annotation can be placed on bean class OR Setter method.

                                NOTE: There is a limitation that a bean variable can't be final. Because value is yet to assign.

                                ex.,
                                    @Component
                                    class Person{
                                        priavte final String name = "Krunal";

                                        @Autowired
                                        priavte Vehicle veh;

                                        @Autowired
                                        public void setVehicle(Vehicle vehicle) {
                                            this.vehicle = vehicle;
                                        }
                                    }

                                @Wiring annotation goes well with @Component because it will automatically wire vehicle to person object.
                                since @component does allow to create multiple instance we will not face ambiguity.

                                Exception is thrown if bean does not exist.

                                ex.,
                                    // only add @autowire to variable in Person() class. if we do not do that vehicle will be NULL for person object.

                                NOTE:
                                    We can trun off "@autowire(required = false)" to avoid exception if bean not found and assign NULL value to it.
                                    Also, we can not use final keyword with @autowired variable.
                 
                Wiring beans using @Wiring on constructor   :
                                To use final keyword for bean variable, we have to implement this method and it's accepted for production.

                                Use it with constructor:
                                ex.,    
                                    public class Person{
                                        priavte final Vehicle veh;

                                        @Autowired
                                        public Person(Vehicle veh){
                                            this.veh = veh;
                                        }
                                    }

                                NOTE:
                                    ->  you can't use default/ zero parametered constructor. as vehicle variable expect value.
                                    ->  @Qualifier can't be used with @Autowire but can be used inside parameter:
                                        ex.,
                                            // Runtime error:
                                                @Autowire
                                                @Qualifier ---> can not be used here wit constructor.
                                                public Person(Vehicle veh){
                                                    ... code ...
                                                }

                                        ex., 
                                            // Works:
                                                @Autowire
                                                public Person( (@Qualifier "Vehicle1") Vehicle veh){
                                                    ... code ....
                                                }

                                    ->  if class has only one constructor, we don't need to write @autowired as it will applied default. but make sure it is not default constructor with 0 parameter.

                                    ex.,
                                        public class Person{
                                            private final Vehicle veh;

                                            ---- writing @autowire is optional ----
                                            public Person(Vehicle veh){
                                                this.veh = veh;
                                            }
                                        }

                Autowiring with multiple Beans of same type :
                                        Spring will try to match Beans with same type. If type is Vehicle then it will try to find same type Bean. 

                                        If multiple is found, it will try to match parameter name but this way has less readibility as anything can be used as parameter so it is not adviced to use.

                                            ex.,                                                
                                                // ProductConfig file
                                                    @Configuration
                                                    class productConfig{
                                                        public Vehicle v1(){
                                                            ...
                                                        }

                                                        public vehicle v2(){
                                                            ...
                                                        }

                                                        @Primary
                                                        public vehicle v3(){
                                                            ...
                                                        }
                                                    }

                                                
                                                // Person.java
                                                    Class Person{
                                                        private final Vehicle veh;

                                                        @Autowire
                                                        public Person(Vehicle v1){
                                                            ... ...
                                                        }
                                                    }

                                                    RESULT: 
                                                        Spring will try to find same type bean but here 3 beans are found. {v1, v2, v3}. so spring will try to match with parameter name in constructor with name of vehicle method from config file.

                                                        As V1 method from config file matches it will show value as per v1.

                                                        If variable name did not match with any method from config file, it will choose @Primary bean.

                                                        OR you can use @Qualifier in constructor.
                                                        ex.,
                                                            // Person.javaClass 
                                                                Person{
                                                                    private final Vehicle veh;

                                                                    @Autowire
                                                                    public Person(@Qualifier("v1") Vehicle veh){
                                                                        ... ...
                                                                    }
                                                                }

Bean Scope (Part 1):
        - Singleton Bean (Default)
        - Prototype Bean
        - Request
        - Session
        - Application

        Syntex -->   " @Scope(BeanDefinition.SCOPE_PROTOTYPE) "

            Singleton (Default) ::
                            Singleton instantiation is default way Where same object is returned for Bean reference. 
                            Singleton Bean have Eager and Lazy concept for Bean creation.

                            Flaw/ Disadvantage -> 
                                When two users tries to access same data, it will create "RACE CONDITION". Where final value depends on last applied changes. It occurs for tread process.
                                ex.,
                                    We have one hashtable. here user1 and user2 tried to change value of key "animal". User1 changed value to "lion" but other changed to "cat". But value of "animal" depends on which thread arrived at last.

                            ex.,
                                HERE single bean "Vehicle" is accessed by V1 and V2 objects. If you print address of object it will same.

                                // Config file:
                                    class productConfig{
                                        @Bean
                                        public Vehicle vehicle(){
                                            return new Vehicle();
                                        }
                                    }

                                // main file:
                                    Vehicle v1 = context.getBean(Vehicle.class);
                                    System.out.println(v1.toString() + " --------------");

                                    Vehicle v2 = context.getBean(Vehicle.class);
                                    System.out.println(v2.toString() + " --------------");
                                    
                                    if(v2 == v1)
                                        System.out.println("same address");
                                    System.out.println(v2.hashCode());
                                    System.out.println(v1.hashCode());

                                    // Changing value on one object reflact on other object as same bean is used for both.
                                    v1.setName("no way");
                                    System.out.println(v2.toString());

            Prototype   ::
                            Prototype used to avoid RACE CONDITION occured by Singleton approach.
                            Here, New object is returned for each Bean reference.
                            Prototype bean does not have Eager instantiation concept because beans are created when needed. 

                            | Scenario                         | Person Scope | Vehicle Scope | Behavior                                                                 |
                            |----------------------------------|--------------|---------------|--------------------------------------------------------------------------|
                            | Both are prototype               | Prototype    | Prototype     | New Person and Vehicle instances are created for each getBean() call.    |
                            | Person: singleton, Vehicle: prototype | Singleton    | Prototype     | Person is shared, but each call to createVehicle() returns a new Vehicle.|
                            | Both are singleton               | Singleton    | Singleton     | Both Person and Vehicle instances are shared. Modifying one affects all references. |

                            ex.,
                                // Person is Singleton while Vehicle is Prototype:
                                    // Config file:
                                        @Configuration
                                        public class AppConfig {

                                            @Bean
                                            @Scope(BeanDefinition.SCOPE_PROTOTYPE)
                                            public Vehicle vehicle() {
                                                return new Vehicle();
                                            }

                                            @Bean
                                            public Person person() { // Singleton by default
                                                return new Person();
                                            }
                                        }

Singleton V/S Prototype ::
        > Singleton is default scope While Prototype is defined scope.
        > Singleton same objects for each bean reference while Prototype scope will return different object for each bean reference.
        > Singleton is used for immutable objects while Prototype used for Mutable object. 
        > singleton is commonly used scope while prototype is rarely used scope.

Singleton Eager & Lazy instantiation ::
                Eager instntiation is deafult behaviour of Spring. Where all beans are created at first by Spring. 
                This approach has one flaw that as all beans are created at first it might take time. Even those bean which we are going to use rarely. For example, Bean creation for "Deactivate my account". Which is rarely used in general.
                
                Hence Lazy instantiation was introduced to avoid bean creation at start. And create bean on demand.

                Eager V/S Lazy:
                    >   Spring's default behavior is Eager while Lazy is defined behaviour.
                    >   Eager will create all Beans at start. While Lazy will create bean on demand.
                    >   Eager will throw exceptions/errors before server start while we might face exceptions/errors using Lazy. ex., Lazy tries to create Bean during execution and it might not be found in IOC container and throws Exception.
                    >   Eager takes lots of space as all Beans are created and reduce Performance. Use of Lazy, maintains performance.
                    >   Eager is used in mostly cases but Lazy is used for rare cases.

                ex.,  
                    If we use @Lazy annotation, bean will created when are using getBean() method. we will see "Bean Creation" printed and after that "Vehicle is created".
                    Without @Lazy, spring will use default @Eagar annotation, where all beans are created. so we will see "Vehicle is created" before "Bean Creation".
                    
                    // Vehicle class:
                        class Vehicle{
                            public Vehicle(){
                                System.out.println("Vehicle is created.");
                            }
                        }
                    // config file:
                        class productConfig{
                            @Bean
                            @Lazy
                            public Vehicle veh(){
                                ...
                            }
                        }
                    // Main file:
                        var context = new ApplicationConfigApplicationContext(productConfig.java);
                        sout("-------- Bean Creation ------------")
                        Var vehicle = context.getBean(Vehicle.class);

AOP (Aspect Oriented Programming):
            Aspect is a logic/programming-code which contains cross-cutting concerns. Where Cross-cutting concerns includes performance monitoring logs, security, transcation management, logging etc,.

            AOP centralized this concerns in separated file. 
            ex.,
                To understand better, let's say we want to check execution start time, end time and total time taken of given Java file inside project.
                To do that, We can write single code. But what if we want to do this for java files inside Beans folder. Then we need to write this non-business code for all java files.  
                To reduce this, we use @Aspect file where we will create a method and write all non-business code. And access whenever we want ny simple adding "Advices" of AOP.

            Advantages of AOP:
                Modularization: Separates cross-cutting concerns from the main logic.
                Reusability: Allows you to reuse aspects across multiple modules.
                Clean Code: Reduces boilerplate code by moving repeated logic to a centralized aspect.
                Improved Maintenance: Easier to update or enhance cross-cutting concerns without modifying business logic.

            Function V/S AOP Aspect:
                AOP Aspect is some what same as Function. Where we define logic somewhere and later we call it where we need to use it. But Both are different.,
                >
                    Fuction follows Scatter Apporach. Function needs to be explicitly called where logic is required.
                    Aspect follows centralized Approach. Where logic, rules and everything is written on same file. We do not need to call them from Main method.
                >
                    Duplication for Function call. If we want to use logic in 10 places, we need to call function from each point.
                    Single Aspect call. Defined Point-cut Expression will make all call.
                >
                    Function creates Thighly Coupling.
                    Aspect creates Loosely Coupling.
                > 
                    Functions clutters the business logic. As we are writing non-business logic inside main method.
                    With AOP Aspect, all concerns are handled without touching Business logic.
                >
                    As business grow, developers might create new methods. And they might forget to add logging Functions to logic.
                    Because of Point-cut Expression, Aspect is applied to automatically and leave no room for human error. 

            NOTE: How to use Aspect inside Project:
                To use AspectJ in project.,
                >   We need to include Dependency inside POM.xml file.  
                >   In config file, enable AOP flag by @EnableAspectJAutoProxy. Which lets Spring know about AOP being used in project.
                >   In Aspect file, use @Component and @Aspect. 
                        @Aspect used to define class as an Aspect. Without it, Spring won't use advices (@Before, @After etc.,) or other Aspect logic.
                        @Component used to ensure class is a bean and it is eligible for Spring lifecycle.
                    
            AOP Jargons:
                Target Object   -   A class on which Aspect code will be intercept.
                Aspect          -   A class in which Aspect code is written.

                Advices         -   Advices are defined action on aspect methods. ex., @Before, @After, @Around
                Point Cut       -   AKA Point Cut Expression. Which specify where the advice should be applied. 
                Join Point      -   From Target Object, methods on which Advice will be applied to.

                ex.,
                    // Vehicle class:   "Vehicle.java" file
                        Class Vehicle{
                            private String name;

                            public void process(){
                                this.name += " @CanadianVersion";
                            }
                        }

                    // Aspect Class:    "LogginAspect.java" file
                        @Component
                        @Aspect
                        public class LogginAspect{
                            @Before("execution(* com.example.service.Vehicle.process(..)))
                            public void logging(){
                                System.out.println("---- Log: Accesing Vehicle ----");
                            }

                            @After("execution(* com.example.service.Vehicle.process(..)))
                            public void exitLogging(){
                                System.out.println("---- Log: Releasing Vehicle ----");
                            }
                        }

            ADVICE types:
                @Before             -   Befre the execution of method, Advice is applied.
                @AfterReturning     -   After the succesful execution of method, Advice is applied.
                @AfterThrowing      -   After Exception is thrown in target method, Advice is applied.
                @After              -   Advice is applied after the execution of method. (no matter exception is thrown or not.)
                @Around             -   Combination of @Before and @After.
                
            Point-cut expression syntex:
                    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
                    
                    NOTE:
                            package com.exmaple;
                            public class Solution{
                                public int checkMaxVal(int[] nums) thorw NullPointerException{
                                    ...     // implementation
                                }
                            }

                            --> modifiers-pattern is "public".
                            --> ret-type-pattern is "int".
                            --> declaring-type-pattern is "com.exmaple.Solution".   { It is combination of PackageName + ClassName.}
                            --> name-pattern is "checkMaxVal".  {It is method name.}
                            --> param-pattern is "int[]".   {It is parameter's data type.}
                            --> throws-pattern is "NullPointerException".

                    LEARN different TYPES OF EXPRESSION SYNTEX., 
                        Match all methods in package:
                            execution(* com.eazybytes.eazyschool..*.*(..))

                        Match all public methods from eazyschool package
                            execution(public * com.eazybytes.eazyschool..*.*(..))

                        Firt query: Match all methods in package
                        Second query: Match admin package's all method.
                        RESULT: Match all methods from both package.
                            execution(* com.eazybytes.eazyschool..*.*(..)) || execution(* com.eazybytes.admin..*.*(..))
                            execution(* com.eazybytes.eazyschool..*.get*(..)) && execution(public * *(..))

                        Match controller folder's ContactController class's all methods.
                            execution(* com.eazybytes.eazyschool.controller.ContactController.*(..))

                        Match displayMessage method with any number of parameters method but from ContactController class.
                            execution(* com.eazybytes.eazyschool.controller.ContactController.displayMessages(..))
                        
                        Match any Constructor of ContactController class. The constructor with 0 parameter or with multiple parameter.
                            execution(com.eazybytes.eazyschool.service.ContactService.new(..))

                        Match all methods who accept 2 parameter String and int from eazySchool package,
                            execution(* com.eazybytes.eazyschool..*.*(String, int))
                        
                        Match any method from eazyschool package but method must have a first parameter as String.
                        Matches can be updateContact(String name, int id) or updateContact(String email)
                            execution(* com.eazybytes.eazyschool..*.*(String, ..))

                        Match any method from eazySchool package but method last parameter of type string    
                        execution(* com.eazybytes.eazyschool..*.*(.., String))

                        Match any get* method.
                        It can be getContact(), getinfo(int id), getNmae(String firstName, String lastName)
                            execution(* com.eazybytes.eazyschool..*.get*(..))
                        
                        Match any methods with 0 signature value from eazySchool package.
                            execution(* com.eazybytes.eazyschool..*.*())






                        execution(String com.eazybytes.eazyschool.service.*.*(..))

            @Order: 
                Execution of Advice is random when multiple files implemented same Advice.
                We can give @Order(1), @Order(3)... for each Aspect file.

            Example., 
                MyAspect.java file:
                @Aspect
                @Component
                @Order(1)
                public class MyAspect {
                    private Logger logger = Logger.getLogger(MyAspect.class.getName());

                    @Around("execution(* com.example.beans.*.*(..))")
                    public void aroundExecution(ProceedingJoinPoint joinPoint) throws Throwable {
                        System.out.println("Around method execution in beans package --- start");
                        joinPoint.proceed();
                        System.out.println("Around method execution in beans package --- end");
                    }

                    @Before("execution(* com.example.beans.*.*(..))")
                    public void beforeExecution(){
                        System.out.println("---> Before method execution in beans package");
                        logger.log(Level.SEVERE, "Severe");
                        logger.log(Level.WARNING, "Warning");
                    }

                    @After("execution(* com.example.beans.*.*(..))")
                    public void afterExecution(){
                        System.out.println("---> After method execution in beans package");
                    }

                    @AfterThrowing(value = "execution(* com.example.beans.*.*(..))", throwing = "ex")
                    public void afterThrowExecution(JoinPoint joinPoint, Exception ex){
                        logger.log(Level.INFO, ex.getMessage());
                    }

                    @AfterReturning(value = "execution(* com.example.beans.*.*(..))", returning = "returnObj")
                    public void afterReturningExecution(JoinPoint joinPoint, Object returnObj){
                        logger.log(Level.INFO, "Successful Execution: " + returnObj);
                    }
                }

            Configuring Advices:
                    > Create Advice interface with @Retention Policy and @Target Runtime.
                    > Add @interfaceName on top of method inside class of "beans" folder.
                    > use "@annotation(com.example.interface.InterfaceName)" --> in aspect file.

                    example.,
                        // interfaces file -> LogAspect.java
                            @Retention(RetentionPolicy.RUNTIME)
                                @Target(ElementType.METHOD)
                                public @interface LogAspect {
                            }
                        
                        // 2nd step: 
                        Add @LogAspect - which is interface file name. On top of any method inside Bean class.
                        
                        // 3rd step: 
                        Aspect folder -> aspect.java file.   
                            @Before("@annotation(com.example.interfaces.LogAspect")
                            public void beforeExecution(){
                                logger.log(Level.INFO, "Annotation Interface.");
                            } 

Servlet     :
                Servlet is Server-side program that used to handle client request, process them and send dynamic response.
                ex.,
                    When you click on "Submit" button on form. The request will execute servlet on server side to validate entry and show message as response. 

Dispatcher Servlet  :
                Servlet inside spring known as "Dispatcher servlet". Which maintains all the URL mapping inside a web Application.
                
                In spring, responsibility of managing servlet goes to Spring framework instead of developers.

Create SpringBot project    :
                Go to "spring initializr" website. (https://start.spring.io/) --> used to generate web project skeleton based on required dependency.
                Configure details.
                Generate Project Zip file and extract it.
                From IDE, file -> new -> "IMPORT MODULE from source" select POM.XML file from extracted folder.
                Rebuilt project to install all dependencies.

                CREATE HELLO WORLD PROJECT:
                        Create HTML page inside resources -> static folder.
                        Create Controller for this html page -> 
                                        @Controller
                                        public class HomeController{
                                            @RequestMapping("home.html")
                                            public String displayHomePage(){
                                                return "home.html";
                                            }
                                        }
                
                NOTES:
                    @SpringBootApplication   -   
                                                It is Spring boot main class.
                                                PSVM{} use "SpringBootApplication.run(currentFileName.class, args) 

                                                It is made out of 3 annotations. {@EnableAutoConfiguration, @ComponentScan, @SpringBootConfiguration}

                    application.properties file   -
                                        Inside this file configure default setting setup by spring framework.
                                        ex.,
                                            server.port = 8077;     --> Assign port: 8077 to Spring application
                                            server.port = 0;        --> Assign any available port to application.
                                            server.servlet.context-path = "kp"      --> add "kp" to website path.  
                                                                    ex.,
                                                                        example.com/home --> redirects to Home page
                                                                        example.com/kp/home --> since context-path = "kp", we need to include "kp" inside web link.

                    debug = true            -
                                        Generates Autoconfiguration report on console.
                                        Which contains information about { positive_Matches, Negative_Matches, Exclusion, Unconditional_classes }        

ThymeLeaf Framework     :   
                    Thymelead has great integration with Spring MVC and Spring Security.
                    We can deploy Thymeleaf adn spring in one server. Not like {Spring + React/ Angular} project, where frontend stored at differentserver than backend files.

                    spring.thymeleaf.cache      :
                                        If cache is "true", thymeleaf will store compiled pages on every Server start and use that pages. Hence you won't see changes refalcted to pages when project is build again. 
                                        If cache is "false", thymeleaf will compile pages every built time. Great for development use.

                    NOTE:
                        This config works for thymeleaf pages, It won't work for backend files. We need to restart server everytime to see changes of backend file.

                    Thymeleaf Page Layouts      ::
                                        th: insert  :
                                                        Insert the child fragment to parent tag.
                                                        Parent's attributes are preserved and child fragment is inserted inside it.
                                        th: replace :
                                                        Replaces the entire parent tag with fragment.
                                                        Parent's attributes are replaced by child attributes.   

                                        NOTE:   content inside of parent will be removed and child fragment is placed instead.
                                            
                                            ex.,
                                                "HOME.html"     :   
                                                    <body>
                                                        <!-- Example with th:insert -->
                                                        <div th:insert="header::headerFragment" class="parent-insert" id="insert-id">
                                                            <p>Insert Example</p>
                                                        </div>

                                                        <!-- Example with th:replace -->
                                                        <div th:replace="header::headerFragment" class="parent-replace" id="replace-id">
                                                            <p>Replace Example</p>
                                                        </div>
                                                    </body>  

                                                "Header.html"   :  
                                                    <div th:fragment="headerFragment" class="child-header" id="child-id">
                                                        <h1>Header Content</h1>
                                                    </div>     

                                                OUTPUT          :
                                                    <body>
                                                        <!-- Example with th:insert -->
                                                        <!-- new child fragment is inserted inside parent -->
                                                        <div th:insert="header::headerFragment" class="parent-insert" id="insert-id">
                                                            <div th:fragment="headerFragment" class="child-header" id="child-id">
                                                                <h1>Header Content</h1>
                                                            </div> 
                                                        </div>

                                                        <!-- Example with th:replace -->
                                                        <!-- all attributes of parent is replaced. -->
                                                        <div th:fragment="headerFragment" class="child-header" id="child-id">
                                                            <h1>Header Content</h1>
                                                        </div> 
                                                    </body>

LOMBOK Library  :
            LOMBOK generates getter, setter, equals(), toString(), hashCode() methods & Constructors at compile time.
            It contains library such as @Getter, @Setter, @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor, @ToString, @EqualsAndHashCode, @Data 

            HOW TO USE LOMBOK:
                Add dependency of LOMBOK library in POM.xml file.

            @Slf4j  -
                Above annotation will remove declaration of logger in POJO file.
                ex.,
                    private static logger log = LoggerFactory.getLogger(Contact.class);
            @AllArgsConstructor -
                Creates a constructor using all available fields inside of class.
                ex.,
                    // HomeController.java
                    @AllArgsConstructor
                    public class HomeController{
                        public final String username;
                        @NotNull
                        public String name;
                        public int age;
                    }
                    // Constructor with all available fields inside class will be generated during compile time will be...
                    public HomeController(String username, String name, int age){   ... }
            @NoArgsConstructor  -
                Creates a default type constructor.
                ex.,
                    // HomeController.java
                    @NoArgsConstructor
                    public class HomeController{
                        public final String username;
                        @NotNull
                        public String name;
                        public int age;
                    }
                    // Default constructor will be generated during compile time will be...
                    public HomeController(){ }
            @RequiredArgsConstructor
                Creates a constructor with only @NotNull or final fields/variable inside of class.
                ex.,
                    // HomeController.java
                    @RequiredArgsConstructor
                    public class HomeController{
                        public final String username;
                        @NotNull
                        public String name;
                        public int age;
                    }
                    // Constructor with @NotNull and final field will be generated during compile time will be...
                    public HomeController(String username, String name){ }

SpringBoot DevTools     :
                    It is a dependency where Automatic restart & LiveReload happens for DEV environment. 
                    It will disable all cache of project so that components/pages/java file will be compiled for every build.

                    NOTE:
                        During built, DevTools won't be included to jav/war files. Making deployment to production easy because we might not need recompilation.

MVC pattern :
            MVC design is used to achieve loosely coupling.
                Model       -   It stores and manages the data from database.
                Controller  -   Bind Model & View together. And used to execute business logic inside.
                View        -   Ui and show data from controller.

Spring MVC Architecture (Interal flow)  :
            step 1: End user send http request to Server container. (Server container can be anything lets say TOMCAT server) 
            step 2: TOMCAT server accept http request and handover request to Dispather servlet.
            step 3: Dispather servlet will check with "Mapping Handler" to get method name and controller.
            step 4: Dispather servlet will invoke controller and its method.
                    After execution controller will return data and view to show the data inside.
            step 5: Dispather servlet finds view by "Resolver view" and render the data retrieved from controller. And send response.
            step 6: Server container will accept response from Dispater server and send it back to server.
            step 7: Server container will convert into HTTP response.
            step 8: Bowser will intercept HTTP response to show content.

URL path    :
            Absolute Path   -   
                        URL path starts with '/'. 
                        When resource file is in the same location. 
                        ex.,
                            Website URL :   https://example.com/folder/page
                            Componenet search   :   https://example.com/assets/css/style-starter.css

            Relative Path   -
                        URL has no '/' at start.
                        when resource file depends on the current folder location. If each html file has it's own CSS file.
                        NOTE: May cause problem using this method for subfolders.
                        ex.,
                            Website URL :   https://example.com/folder/page
                            Componenet search   :   https://example.com/folder/assets/css/style-starter.css

Controller      :
            Terms:
                    @RequestMapping(value = "/htmlPage")    -    Maps web requests to specific handler methods.
                    @RequestMapping(value = "/saveMsg", method = RequestMethod.POST)    -   Handle post request coming from a form with name = "saveMsg".
                    @PostMapping(value = "/saveMsg")    -   alternate of above method and handle POST request.     

            Create individual controller:
                ex.,
                    @Controller
                    public class HomeController {

                        @RequestMapping(value={"", "/", "home"})
                        public String displayHomePage() {
                            return "home.html";
                        }

                    }

            Create mapping Controller to avoid multiple creation of controller:
                ex.,
                    @Configuration
                    public class WebConfig implements WebMvcConfigurer {
                        @Override
                        public void addViewControllers(ViewControllerRegistry registry){
                            registry.addViewController("/courses").setViewName("courses");
                        }
                    }

            Data binding Process:
                            The name attribute of field from frontend is binded with @RequestParam of backend.
                                example.,
                                    // Front-end:
                                        <form th:action="@{/saveMsg}" method="post" class="signin-form">
                                            <input type="text" name="name" id="name" placeholder="Enter Your Name" />

                                    // Back-end:
                                        @PostMapping(value = "saveMsg")
                                        public ModelAndView saveMessage(
                                                @RequestParam String name,       // Matches name="name"
                                                @RequestParam String mobileNum,  // Matches name="mobileNum"
                                                @RequestParam String email,      // Matches name="email"
                                                @RequestParam String subject,    // Matches name="subject"
                                                @RequestParam String message     // Matches name="message"
                                        ){
                                            ... // code ...
                                        }

Query param V/S Path param  :
            Query param used for filter, sort or search. And it's format contains key-value pair after '?' in url.
            ex.,
                Filter products with 'electronic' category and sorting based on price Ascending.
                GET /products?category=electronic&sort=price
            
            Path param used to identify specific resource. Injected directly inside URL.
            ex.,
                Fetch product with id = 123.
                Get /products/123

Query params using @RequestParam   :
            getParameter() is a URL parameter that is used when a client or browser sends a request to a server.
            ex.,
                www.kpriyadarshi.ca/certificate?year=2021&order=asd
                Above link is with Query parameter.

            code configuration -
                Step 1 : Add queryParameter to any frontend link.
                    // Footer.html
                    <li><a th:href="@{/holidays(festival='true',federal='true')}">Holidays</a></li>
                Step 2 : Handle Query parameter from controller of the page. Make parameter non-required as it's used as filter.
                    // HolidayController 
                    @GetMapping(value = "/holidays/{display}")
                    public String displayHolidays(@RequestParam(required = false) boolean festival,
                                  @RequestParam(required = false) boolean federal,
                                  Model model){ ... }
                Step 3 : use th:if to hide or show <div> on frontend.
                    // holiday.html
                    <div class="col-lg-6" th:if="${festival} == true">

Path params using @PathVariable :
            Path params is.,
            ex., 
                www.kpriyadarshi.ca/certificate/all      

            Code configuration -
                Step 1 : Add Path param to the frontend side. Here, Path param is "all" string which will send to the backend side.
                    // Footer.html
                    <li><a th:href="@{/holidays/all}">Holidays</a></li>  
                Step 2 : Fetch Path param from backend side.
                    //  HolidayController.java
                    @GetMapping(value = "/holidays/{display}")    
                    public String displayHolidays(@PathVariable String display, Model model){ 
                        if(display != null && display.equals("all")){
                            model.addAttribute("federal", true);
                            model.addAttribute("festival", true);
                        }
                    }
                Step 3 : Use th:if to show or hide content at front end.
                    // holiday.html
                    <div class="col-lg-6" th:if="${festival} == true">

Spring Validation   :
            In html, we have required attribute to make field required during form submittion.
            ex.,
                <input type="text" name="name" id="name" placeholder="Enter your name" required>

            But it can be easily bypass by browser console where user will remove attribute by deleting it.
            Or by injecting javascript code. document.getElementById('name').removeArrribute('required');

            JAKARATA VALIDATION & HIBERNATE VALIDATION  :
                        jakarta.validation.constraints.*
                            @Digits
                            @Email
                            @Max
                            @Min
                            @NotNull    -   Return true for not null value. ex., "" (Empty string), " " (White space), "   ", "abc", " abc " 
                            @NotEmpty   -   Return true for at least one character. ex., " " (white space), "   ", "abc", " abc "
                            @NotBlank   -   Return true for at least one non-white space character. It is like performing trim() on value and check if it has character in it or not. ex., "abc", " abc " 
                            @Pattern
                            @Size

                        org.hybernate.validator.constraints.*
                            @CreditCardNumber
                            @Length
                            @Currency
                            @Range
                            @URL
                            @UniqueElements
                            @EAN
                            @ISBN

                        @NotNull V/S @NotEmpty V/S @NotBlank  :
                            | Example Value       | @NotNull | @NotEmpty | @NotBlank |
                            |---------------------|----------|-----------|-----------|
                            | null                | False    | False     | False     |
                            | "" (empty string)   | True     | False     | False     |
                            | " " (space)         | True     | True      | False     |
                            | "abc"               | True     | True      | True      |
                            | " abc "             | True     | True      | True      |
                            | "123"               | True     | True      | True      |
                            | "0"                 | True     | True      | True      |
                            | "true"              | True     | True      | True      |
                            | "false"             | True     | True      | True      |
                            | " " (3 spaces)      | True     | True      | False     |

            Implement Jakarta Validation on MVC project :
                        Step 1. Add model attribute onject contact to bind data with front end field.
                                ex.,
                                    @RequestMapping(value = "/contact")
                                    public String displayContactPage(Model model){
                                        model.addAttribute("contact", new Contact());
                                        return "contact.html";
                                    }
                        Step 2. Add th:object and th:field inside HTML page. This will bind field from HTML page to variable of POJO class.
                                NOTE: field name on HTML page and variable name on POJO class must be same to bind data. Else we need to use "name" attribute inside POJO class.
                                ex.,
                                    // contact.html
                                    <form th:action="@{/saveMsg}" method="post" h:object="${contact}">
                                        <input type="text" th:field="*{name}" required="true"/>
                                    </form>
                        Step 3. Add validation on POJO class. "Contact.java"
                                ex.,
                                    @NotBlank(message = "Enter name")
                                    private String name;
                        Step 4. When button on form page is pressed, pointer goes to controller of the page. 
                                Here we tell MVC to perform Validation and return Errors.
                                ex.,
                                    // ContactController.java
                                    @RequestMapping(value = "/saveMsg", method=POST)
                                    public String saveMessage(@Valid @ModelAttribute("contact") Contact contact, Errors errors){
                                        if(errors.hasErrors()){
                                            log.error(errors.toString());
                                            return "contact";
                                        }
                                        return "redirect:/home";
                                    }
                        Step 5. Show all errors to HTML page from controller class.
                                ex.,
                                    // contact.html
                                    <ul>
                                        <li class="alert alert-danger" role="alert" th:each="error: @{#fields.errors('contact.*')}"></li>
                                    </ul>

Bean Scope (Part 2) :
            Request scope   -   
                        Spring creates new instance of bean for every HTTP request.
                        If user make 50 http_request to server, it will create a single bean for each http request. And these beans live for short duration and it's being collected by Garbadge collector. Hence avoid creating unneccessary request bean in application as it will it performance.
                        ex.,
                            Use request bean for passing credentials of users. As these details are not being stored in server after the use, request scope is perfect for this scenario.
            Session scope   -   
                        Spring creates new instance of bean for defined session time in server memory.
                        Session scoped bean lived for defined time. Hence avoid keeping too much infomation on session as it might hit performance.
                        Never store sensitive information inside Session scoped beans.
                        ex.,
                            userName that we show on multiple pages of application is defined as Session scope.
            Application scope   -   
                        Spering creates only one instance of bean for whole application run time.
                        Singlton and Application scope are so much similar but there are some edge cases, we want to use this other type of scope.
                        Avoid use of Application scoped beans unless needed as it also hit performance of web app. Instead of Application scoped bean, We can fetch data from database or caching. 
                        NOTE: Race condition can occur for Applicationscope.
                        ex.,
                            Each singlton scoped bean is created for each ApplicationContext but a web app can have multiple ApplicationContext.
                            While one Application scoped bean created for the whole web app. 

            NOTE:   
                Singleton & Prototype scope can be used inside web application or simple java code.
                Request/Session/Application scope can be used inside only web application as it works on HttpRequest.

SpringBoot Security :
            SpringBoot security brings Security related features to web app such as Authentication, Authorization etc.
            It protects webapp from Unauthorized access, CSRF, XSS, SQL Injection, Brute force attacks, Session hijacking etc.

            Authentication V/S Authorization:
                ->  Authentication is used to check user's identity using id-password or OTP.
                    Authorization is used to check user's authority by checking their assigned role.
                ->  Authentication occurs before Authorization.
                ->  If Authentication fails it response 401 error message.
                    While Authorization fails we get 403 response.

            Implement SpringBoot Security   :
                Step 1.
                    Add dependency to POM.xml file. And load maven changes.
                    NOTE:   
                        After adding Springboot security, Authentication is implemented by default. Hence we will be redirected to login page initially. Where password is generated by spring security framework and it is available on Server Console.

                        We can create custom creds instead of spring security generates id-password on server console.
                        GENERALLY this method is used for POC but for PRODUCTION, we have to use Database/ OAUTH2 servers for id-password as there can be so many users.

                        Add id-password to "application.properties" file:
                            spring.security.user.name = krunal
                            spring.security.user.password = 12345678

                        This time password won't be generated on server console. And we can use id-password from application.properties file.

                Step 2.
                    Create securityConfig file:
                    ex.,
                        @Configuration
                        public class securityConfig{
                            @Bean
                            // Security Filter Chain are defined security rules for Http requests.
                            SecurityFilterChain defaultSecurityFilterChain(httpSecuirty http) throws Exception{
                                http.
                                    // Configure how http requests are authorized
                                    authorizeHttpRequests(
                                        // permit all incoming http requests
                                        auths -> auths.anyRequest().permitAll()
                                    )
                                    // Provides a default login page for users to log in. If a user is not authenticated.
                                    .formLogin(Customizer.withDefaults())
                                    // Enables basic Authentication for APIs.
                                    .httpBasic(Customizer.withDefaults());

                                return http.build();
                            }
                        }

            permitAll() -   
                        Accept all incoming http request. Used to allow access to the resource file CSS/JS/Assets.
            denyAll()   -   
                        Denies all incoming http request. Used for temporay retired APIs or for some testing purpose. 
                        When we try to access such denied resource, it will send "403 response".
            anyRequest()    -
                        Matches all incoming requests (global matcher/ catch-all rule).
                        ex.,
                            http.authorizeHttpRequests(authz -> authz
                                    .requestMatchers("/admin/**").hasRole("ADMIN") // Only ADMIN can access /admin/**
                                    .anyRequest().permitAll()                      // All other requests are allowed
                            );  
            requestMatchers()   -
                        Match specific pattern of http request.
                        ex.,
                            // Matches "http://localhost:8080/home" but does not match "http://localhost:8080" and send 403 response.
                            http.authorizeHttpRequests(authz -> authz
                                    .requestMatchers("/home").permitAll()        // only "/home" matched requests will have access/
                                    .anyRequest().denyAll()                      // not matching requests will be rejected and 403  response will be sent once user is logged in.
                            ); 

                            // In controller "", "/", "/home" path returns "home.html" string. so we need to include each request.
                            http.authorizeHttpRequests(auths -> auths
                                    .requestMatchers("/index", "/", "/home").permitAll() 
                                    .anyRequest.denyAll()
                            )

                            NOTE:
                                we can not use "" in requestMatchers as pattern can't be empty.
                                Hence we have to use "/index" pattern to match "" request.

                            // HolidayController has Path variable and url changes accroding to that.
                            ex., 
                                /holiday/all    -   to show all federal and festival holiday
                                /holiday/festival   -   to show all festival holiday
                                /holiday/federal    -   to show all federal holiday

                                http.authorizeHttpRequests(auths -> auths
                                        .requestMatchers("/holiday/**").permitAll() 
                                        .anyRequest.denyAll()
                                )
                        
                        NOTE:   
                            We need to give access to the public resource such as CSS file, Js file, assets folder. As Spring security, secure all component of web app.

                            Hence do this.,
                                    .requestMatchers("/assets/**").permitAll() 
            authenticated() -
                        A request will be accessible by authenticated users- those who are logged in.
                        ex.,
                            http
                                .authorizeHttpRequests(auth -> auth
                                    .requestMatcher("/home").authenticated()
                                )
                                .build();

            CSRF Token    :
                        CSRF is a token used to prevent attack such as cross-site request.
                        It is token gnereated by server and during each http request, client has to sent it with http request otherwise server will reject the request. 

                        By default, Spring security enables CSRF for all Http methods which can alter data like POST, DELETE, UPDATE etc. And also for login and logout action as they are state changin action.
                        But spring security is not enable for GET method.

                        Syntex:
                            // inlcude in login.html so Spring security and thymeleaf can handle all.
                            <input type="hidden" th:name="${_csrf.parameteName}" th:value="${_csrf.token}" />

                        http.csrf().disable()  -
                                    Used to disable CSRF for whole application. 
                                    ex.,
                                        http.csrf().disable();
                        http.csrf.ignoringRequestMatcher()  -
                                    Used to disable CSRF for specific action.
                                    ex.,
                                        ttp.csrf.ignoringRequestMatcher("/saveMsg");

                        NOTE: 
                            SpringSecurity has default behaviour in which CSRF is handle. It will send 403 response if invalid http request is receieved.
                            When you use ReactJS or AngularJS, developer have to handle CSRF but with thymeleaf is not needed as thymeleaf handle CSRF by detault.
                            ex.,
                                // Regular form submit action which result in 403 response as it is vulnerable to CSRF attack.
                                // home.html
                                <form action="/saveMsg"> </form> 
                                
                                // To avoid 403 response, You can disable it in config file by,
                                http.csrf().disable();
                                Or http.csrf(AbstractHttpConfigurer::disable);
                                or http.csrf(csrf -> csrf.disable());
                                
                                // But it increses the risk of CSRF attack.
                        
                        NOTE:
                            When CSRF is disable on config file. Spring stops generating and validating CSRF token.
                            As a result, attacker can take sessionId "JSESSIONID" from cookies which is maintained by the web container in the form of cookie.
                            Attackers can take this sessionId and show them as authorized peroson and inject JavaScript code to webApp.

            CSRF lifecycle  :
                        For data-manipulating (POST, DELET, UPDATE) or state-changing (LOGIN, LOGOUT) actions, the request first goes to the SecurityFilterChain.

                        If ignored/permitted, it proceeds to the controller.

                        If not permitted, it triggers authentication/authorization checks.

                        After passing checks, the controller processes the request and redirects as needed.

                        If controller has @Valid then it checks validation that is defined inside class file.

                        After the validation of controller, if service class is used. Pointer goes to service class and then data layer to save data.

            Store information in web app memory :
                        Create a method with return type "InMemoryUserDetailsManager" which object will store all user details like usernane, password, role etc.
                        ex.,
                            // SecurityConfig.java
                            @Bean
                            public InMemoryUserDetailsManager userDetailsService(){
                                // user 1
                                UserDetails admin = User.builder()
                                    .username("k")
                                    .password("1")
                                    .roles("ADMIN", "USER")
                                    .build();

                                // user 2
                                UserDetails user = User.builder()
                                    .username("p")
                                    .password("1")
                                    .roles("USER")
                                    .build();

                                return new InMemoryUserDetailsManager(user, admin);
                            }

Spring Security & thymeleaf :
            To load dynamic rendering to web app, this extra package used to fetch data such as user logged in or not, authorized or not etc.
        
            sec:authorize="isAnonymous()"   -   true if User is Anonymous.
            sec:authorize="isAuthenticated()"   -   true if User is logged in to the system.
            sec:authorize="hasRole("name")  -   true if string matches with User's role.
            sec:authorize="hasAnyRole('ROLE_USER', 'ROLE_ADMIN')"   -   true if user has any role from list.
            
            sec:authentication="name"   -   Displays the username of the authenticated user
            sec:authentication="autorities"   -   Displays the authorities (roles) associated with the currently authenticated user.
            sec:authentication="principal"  -   Displays the entire principal object (usually the user details object that contains username, roles, etc.).

            IMPLEMENTATION OF SPRING SECURITY & THYMELEAF:
                        Step 1: inlcude dependency inside POM.XML file                   
                            <dependency>
                                <groupId>org.thymeleaf.extras</groupId>
                                <artifactId>thymeleaf-extras-springsecurity6</artifactId>
                            </dependency>
                        Step 2: Add xlms: to your header.html file to use dynamic rendering.
                            // header.html  
                            <html lang="en" xmlns:th="http://www.thymeleaf.org"
                                xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity6">
                        Step 3: Use sec:authorize & sec:authentication attribute:
                            // header.html
                            <li class="nav-item" sec:authorize="isAnonymous()">
                                <a th:href="@{/login}" class="nav-link">LogIn</a>
                            </li>
                            <li class="nav-item" sec:authorize="isAuthenticated()">
                                <a th:href="@{/logout}" class="nav-link">logout</a>

Exception Handler   : 
            @ExceptionHandler used to handle exceptions during runtime of WebApp.

            @ExceptionHandler can be used with one controller @Controller to handle any exception occured in the specific controller class.
            ex.,
                Here we are handling 2 exceptions thrown for HomeController with @ExceptionHandler:    
                // HomeController.java
                @Controller
                public class HomeController{
                    @RequestMapping("/home")
                    public String displayHomePage{
                        return "home.html";
                    }

                    @ExceptionHandler({
                        NullPointerException exception,
                        IOException exception
                    })
                    public ModelAndView handleException(RuntimeException ex){
                        .. code..
                    }
                }

            @ExceptionHandler can be used for all controller using @ControllerAdvice.
            ex.,
                // GlobalExceptionController.java
                @ControllerAdvice
                public class GlobalExceptionController{
                    // Parent class of all exceptions.
                    @ExceptionHandler(Exception.class)
                    public ModelAndView handleException(RuntimeException ex){
                        .. code..
                    }
                }

            ??? Why ModelAndView was used here?

H2Databse   :
            Wheneeer we start server, we need to create data schema and table. 
            Because when we terminate/restart server all the information have been lost and during start of server, new memory is initialized.

            It is used for Non-Production environment to avoid creation of SQL/oracle database instead focus on building and testing demo project quickly.

            IMPLEMENT H2DATABASE    :
                        step 1: Include dependency to POM.xml file.
                            code:
                                <dependency>
                                    <groupId>com.h2database</groupId>
                                    <artifactId>h2</artifactId>
                                    <scope>runtime</scope>
                                </dependency>
                        step 2: Add configuration to application.properties
                            code:
                                spring.datasource.url=jdbc:h2:mem:testdb
                                spring.datasource.driverClassName=org.h2.Driver
                                spring.datasource.username=sa
                                spring.datasource.password=
                                spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
                                spring.h2.console.enabled=true
                                spring.h2.console.path=/h2-console
                                spring.jpa.hibernate.ddl-auto=update
                                spring.jpa.show-sql=true
                        step 3: Access "h2console" but before that add permitAll() and CSRF friendly.
                            ex.,
                                http.csrf(
                                    csrf -> csrf.ignoringRequestMatcher(PathRequest.toH2Console())
                                )
                                .requestMatchers().permitAll(PathRequest.toH2Console());
                        step 4: Disabling Spring security when security trying to deal with frame component.
                            code:
                                http.headers(headersConfigurer -> headersConfigurer
                                        .frameOptions(frameOptionsConfig -> frameOptionsConfig.disable()));
                        step 5: Go to /h2-console link:
                            link:
                                http://localhost:8080/h2-console/
                        
                        NOTE:
                            For CSRF use PathRequest.toH2Console() method instead of using String "/h2console".
                            Else with the string "/h2console" will not work.

JDBC    :
            With JDBC there are lots of stpes to connect database.,

            Steps to access Database using JDBC:
                Load driver class
                Obtain a DB connection
                Obtain a statement suing connection object
                Execute the query
                Process the result set
                Close the connection

JDBCTemplate :
            Because of JDBCTemplate, we do not need to load driver class, create DB connection, catch exception and handle it etc.
            JDBCTemplate will take care of that and we can focus on creating business logic.
            JDBC is used as backend for Advance framework such as Spring Data, Hybernate etc.

            SAVING DATA TO DATABASE:
                        step 1.
                            Data goes from HTML page -> controller class -> service class -> Repo class 
                        step 2.
                            // contact.html
                            <form action="/saveMsg" method="post" class="signin-form" th:object="${contact}">
                                <input type="text" th:field="*{name}" placeholder="Your Name" class="contact-input" />
                        step 3.
                            // contactController.java
                            @Autowired
                            private final ContactService contactService;  

                            @RequestMapping(value = "/saveMsg",method = POST)
                            public String saveMessage(@Valid @ModelAttribute("contact") Contact contact, Errors errors) {
                                if(errors.hasErrors()){
                                    log.error("Contact form validation failed due to : {}", errors.toString());
                                    return "contact.html";
                                }
                                contactService.saveMessageDetails(contact);
                                return "redirect:/contact";
                            }
                        step 4.
                            // ContactRepository.java
                            @Repository
                            public class ContactRepository {
                                @Autowired
                                private final JdbcTemplate jdbcTemplate;

                                public int saveContactMsg(Contact contact){
                                    String sql = "INSERT INTO CONTACT_MSG (NAME) VALUES (?)";
                                    return jdbcTemplate.update(sql,contact.getName());
                                    }
                            }
            
            QUERY DATA FROM DATABASE AND SHOW INSIDE HTML PAGE: 
                        flow: 
                            When user load "/messages.html" page, the pointer goes to SecurityConfig file.
                            And checks if current user has permission/permit for current HttpRequest.
                            If user has access, pointer goes to controller of it. And checks if modelAndView assign it or not.
                            Here, it is getMapping request.
                            So controller will call service and service call Repository class and fetch data from database.
                            Here we need to map data from database column to object field using Mapper.
                        
                        step 1.
                            Create a Mapper to bind data with column to object fields:

                            NOTE: 
                                Mapper class has 2 parameters:
                                    ResultSet is data retrieved from SQL query.
                                    rowNum shows which row in the result set is currently being processed.
                            
                            // ContactRowMapper.java
                            public class ContactRowMapper implements RowMapper<Contact> {
                                @Override
                                public Contact mapRow(ResultSet rs, int rn) throws SQLException {
                                    Contact contact = new Contact();
                                    contact.setContactId(rs.getInt("CONTACT_ID"));
                                    contact.setName(rs.getString("NAME"));

                                    System.out.println("Row Number: " + rowNum);
                                    return contact;
                                }
                            }

                            NOTE: 
                                We can skip creating Mapper class if field name from SQL column is exactly like variable name inside class.

                                Update Repository class and use BeanPropertyRowMapper.newInstance(className.class) which will create RowMapper.
                                // ContactRepository.java
                                @Repository
                                public class ContactRepository{
                                    @Autowired
                                    public JdbcTemplate jdbcTemplate;

                                    public List<Contact> getAllContacts(){
                                        String sql = "SELECT * FROM contact";
                                        return jdbcTemplate.query(sql, new BeanPropertyRowMapper.newInstance(Contact.class));
                                    }
                                }
                        step 2.
                            Use Mapper and jdbc.query() to fetch data from database.

                            NOTE:
                                jdbcTemplate has 3 parametes:
                                    Sql query in string format
                                    PreparedStatementSetter() which is used to set value for ? in query
                                    Mapper to bind data with database column data to class field

                            // ContactRepository
                            @Repository
                            public class ContactRepository {
                                @Autowired
                                private final JdbcTemplate jdbcTemplate;

                                public List<Contact> findMsgsWithStatus(String status){
                                    String sql = "SELECT * FROM contact_msg WHERE status = ?";
                                    return jdbcTemplate.query(sql, new PreparedStatementSetter() {
                                        @Override
                                        public void setValues(PreparedStatement ps) throws SQLException {
                                            ps.setString(1, status);
                                        }
                                    }, new ContactRowMapper());
                                }
                            }

                        step 3.
                            Service object to perform business logic and call above Repository method to fetch data:
                            ex.,
                                // ContactService.java
                                public List<Contact> findMsgsWithOpenStatus(){
                                    List<Contact> contactMsgs = contactRepository.findMsgsWithStatus(EazySchoolConstants.OPEN);
                                    return contactMsgs;
                                }
                        
                        step 4.
                            Controller class to set view-model or redirect.
                            In this case, we will set model and view to show data to getMapping request.

                            ex.,
                                // ContactController.java
                                @RequestMapping(value = "/displayMessages", method = RequestMethod.GET)
                                public ModelAndView displayMessage(){
                                    List<Contact> contactMsgs = contactService.findMsgsWithOpenStatus();
                                    ModelAndView modelandview = new ModelAndView("messages.html");
                                    modelandview.addObject("contactMsgs", contactMsgs);
                                    return modelandview;
                                }

                        step 5.
                            Show data to html page:
                            ex.,
                                // messages.html
                                <tr th:each="msg: ${contactMsgs}">
                                    <td th:text="${msg.name}"></td>
                                    <td><a th:href="@{/closeMsg(id=${msg.contactId})}" class="btn btn-style btn-style-3">CLOSE</a></td>
                                </tr>

NamedParamaeterJDBCTemplate :
            instead of using '?', we are providing field name in NamedParamaeterJDBCTemplate.
            It just provide more readibility to code than JDBCTemplate.

            ex.,
                // Contact.java
                @Data public class Contact{
                    public String name;
                }  

                // ContactRepository.java
                @Repository
                class ContactRepository{
                    @Autowire
                    private NamedParamaeterJDBCTemplate namedParamaeterJDBCTemplate;

                    public int saveContact(Contact contact){
                        String sql = "INSERT INTO contacts (name) values (:name)";
                        // map parameters
                        SqlParameterSource parameters = new SqlParameterSource().addValue("name", contact.getName());

                        return namedParameterJdbcTemplate.update(sql, parameters);
                    }
                }

AWS RDB :
            Perform AWS setup and create RDB    -
                        user name   :   admin
                        password    :   12345678
            Create inBound rules    -
                        type    :   MySQL/Aurora
                        source  :   ipv4/ ipv6
            Add Dependency to Maven project -
                        MySQL driver dependency
                        ex.,                     
                            <dependency>
                                <groupId>com.mysql</groupId>
                                <artifactId>mysql-connector-j</artifactId>
                                <scope>runtime</scope>
                            </dependency> 
            MySQL database setup    -
                        Schema.sql, data.sql add these two files and execute 'em.
            Add config file -
                        spring.datasource.url = jdbc:mysql://spring.cp4gaege6w9w.us-east-2.rds.amazonaws.com
                        spring.datasource.username = admin
                        spring.datasource.password = 12345678

                        NOTE:
                            url is "jdbc:mysql://" + AWS's Endpoint + DB name from MySql 
                            username and password are from initial AWS RDB Database setup.

Spring DATA :
            It is spring framework which simplifies data access for application. In result, developers do not need to write extra code to access these data from DB.
            There are many modules like.,
                Spring JDBC,
                Spring DATA JPA,
                Spring DATA REST., etc

Spring JDBC :
            Spring JDBC is limited ORM (Object Related Mapping) framework.
            It is small version of Spring DATA JPA.
            It does not offer caching, lay loading and many features that JPA provides.

ORM (Object Related Mapping)    : 
            Map tables to Classes.
                Columns map to fields (attributes) in the class.
                Rows map to Object of class.
            Managing Relationship 
                ORM handles all One-to-one, One-to-many, many-to-many
            Automatic SQL query generation
            Session Management
            Persistence Context

Spring DATA JPA :
              

Exceptions  :
                NoSuchBeanDefinitionException       :
                            When you try to get bean using context.getBean("Vehicle.class") and no vehicle bean is found from IOC container. It will return this exception.

                NoUniqueBeanDefinitionException     :
                            When you try to inject a bean by a type but project config file has multiple beans with same type, this Exception is thrown.
                            ex.,
                                // projectConfig.java
                                    @bean
                                    String firstName(){
                                        return "John";
                                    }

                                    @bean 
                                    String lastName(){
                                        return "Doe";
                                    }

                                // main.java
                                    var context = new AnnotationConfigApplicationContext(projectConfig.class);
                                    var name = context.getBean(String.class);  
                                    // Exception will be thrown as there are two beans with same type.   

                                    //use this instead:
                                    var name = context.getBean("firstName", String.class);  // John
                                    var name2 = context.getBean("lastName", String.class);  // Doe

                                    // Or use @Primary Annotation in projectConfig.java class.
                                
                            NOTE:   
                                if we have x2 @Primary annotation for same data types we will get Exception "NoUniqueBeanDefinitionException" with proper message saying "more than 1 @Primary annotation".

                UnsatisfiedDependencyException      :
                            When Circular dependency is created, this exception is thrown.
                            When A bean trying initiate another bean and other bean is try to initiate first bean. This exception is thrown. 
                            There is no solution for this. So we have to avoid this situation.

                            It can be easily discovered as we can not even start out server.

                            ex.,
                            // Circular dependency:
                                class person{
                                    @Autowired
                                    private Vehicle veh; // person class is trying to initiate vehicle class.
                                }

                                class Vehicle{
                                    @Autowired
                                    private Person p;   // vehicle class is trying to initiate person class.
                                }

Logger Level    ::
        (General logging level - QA team)
            Fatal       -   System crash or not working.
            Error       -   Issue on system but functionalities are working properly.
            Warn        -   Unexpected behaviour (System working fine)
            Info        -   Informative event occured.
            Debug       -   Useful while debugging the code.
            Trace       -   For extended debugging sessions.

        (Java Built-in Logger)
            SEVERE      -   Critical Error
            WARNING     -   Unexpected behavior but system works fine.
            INFO        -   general information realated message.
            CONFIG      -   configuration-related message.
            FINE        -   detailed Trance-debugging message.
            FINER       -   even more detailed Debugging message.
            FINEST      -   finest level of debugging message.

        Syntex  :
            logger.log(Level.SEVERE, "This is a message.");
            logger.log(Level.INFO, "Informative message.");
            logger.log(Level.CONFIG, "Configuraion message.);
            ...
